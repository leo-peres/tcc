\chapter{Computação relativizada e complexidade de circuitos} \label{chapter_oracles_and_circuit_complexity}

Neste capítulo nós vemos como circuitos e complexidade ``relativizada'' se relacionam.

\section{Uma prova alternativa do teorema \ref{teo: bgs}} \label{section_alternative_proof_bgs}

Nós já vimos que existem oráculos $A$ e $B$ satisfazendo $\P^{A} = \NP^{A}$ e $\P^{B} \neq \NP^{B}$. Neste capítulo nós vemos uma outra prova do segundo resultado que mostra a idéia geral de como conectamos limites inferiores a resultados em complexidade relativizada. Basicamente, nós usamos a incapacidade de certos dispositivos computacionais (por exemplo, circuitos de baixa profundidade) de computar certas funções mais o fato que certas classes de complexidade podem ser expressas por estes mesmos dispositivos computacionais para, ironicamente, diagonalizar e provar separação por oráculo. Note que essa é a mesma idéia que usamos anteriormente para provar o teorema \ref{teo: bgs}, porém se tentassemos generalizar aquele argumento para provar que $\PH^{A} \neq \PSPACE^{A}$ nós esbarrariamos em alguns problemas como por exemplo ter que simular cada máquina de Turing um número exponencial de vezes o que destroi a nossa hipótese que uma máquina de Turing de tempo polinomial só faz uma quantidade polinomial de consultas ao oráculo, e também podemos ver que trabalhar com modelos que apresentam uma estrutura combinatórica como circuitos Booleanas é muito menos problemático.

Nós iremos considerar a função Tribes$_{N}$ que vimos na introdução. Uma das propriedades de Tribes$_{N}$ é que ela é \emph{evasiva}, o que significa que ter conhecimento apenas parcial dos bits da entrada não é suficiente para avaliar a função. Para formalizar isso, suponha que nós temos uma função $f: \{0, 1\}^{n} \to \{0, 1\}$ e queremos computar $f(x)$ para alguma entrada $x$. Nós podemos fazer isso somente consultando cada bit de $x$ sem nos preocuparmos com a complexidade das computações intermediárias. Desta formas podemos definir diversas medidas de complexidade de $f$. A medida que nos interessa no momento é a complexidade de consulta determinística:

\begin{defi}

A complexidade de consulta determinística de um algoritmo $A$ é o maior número de consulta aos bits da entrada sobre todas as entradas $x \in \{0, 1\}^{n}$ que $A$ faz.

Seja $f: \{0, 1\}^{n} \to \{0, 1\}$. A complexidade de consulta determinística de $f$, que denotamos por $D(f)$, é o mínimo da complexidade de consulta determinística de todos os algoritmos que computam $f$.

\end{defi}

A partir de agora quando dissermos complexidade de consulta fica implícito que estamos falando da complexidade de consulta determinística.

Nós podemos representar as consultas feita pelo algoritmo através de uma árvore de decisão, onde em cada consulta o algoritmo ramifica para a esquerda ou para direita dependendo do valor do bit consultado. Desta forma $D(f)$ é a profundidade mínima entre todas as árvores de decisão que computam $f$.

Para ver que Tribes$_{N}$ é evasiva bastar considerar o cenário em que nenhuma consulta revela o valor de uma das tribos (isto é, a consulta sempre retorna 1) até que o último bit da tribo seja consultado e acaba sendo 0. Assim mesmo que todas exceto uma tribo tenha todos seus bits revelados o valor desta última tribo vai ser incerto até que a última consulta seja feita. Isso pode ser traduzido como $D(\text{Tribes}_{N}) = N$. Também poderiamos ter usado o seguinte fato:

\begin{fato}
Para todas funções $f: \{0, 1\}^{n} \to \{0, 1\}$, $deg(f) \leq D(f)$.
\end{fato}

E como vimos em \ref{prop: tribes_fourier_coef}, deg(Tribes$_{n}$) = n.

Agora, seja $M$ uma máquina de Turing que pode fazer consultas a algum oráculo, e seja $x \in \binalph^{*}$. O que $M$ faz antes de tua primeira consulta é independente de qual oráculo ela tem acesso, e o que $M$ faz entre a primeira e segunda consulta só depende da resposta à primeira consulta, e por aí vai. Isto sugere que a computação de $M$ sobre a entrada $x$ pode ser representada por um algoritmo de consulta que ramifica sobre as respostas às suas consultas ao oráculo.

Seja $\mathcal{X}$ um subconjunto finito de $\binalph^{*}$ e $A \subseteq \binalph^{*} \setminus \mathcal{X}$ um oráculo que inicialmente está definido apenas nas strings que não estão em $\mathcal{X}$. Sejam $M$ e $x$ os mesmos do parágrafo anterior, então o algoritmo de consulta $T_{M^{A}, x}^{\mathcal{X}}$ ramifica sobre consultas ao oráculo por strings em $\mathcal{X}$. Podemos ver a entrada de $T_{M^{A}, x}^{\mathcal{X}}$ como um vetor característica $v$ onde $v_{j} = 1$ significa que a $j$-ésima string na ordem lexicográfica em $\mathcal{X}$ está em $A$. Desta forma, temos que $T_{M^{A}, x}^{\mathcal{X}}(v) = 1 \iff M^{A \cup v}(x) = 1$, permitindo um pequeno abuso de notação. Em particular, se $M$ roda em tempo polinomial e $\mathcal{X} = \binalph^{\lvert x \rvert}$ então $T_{M^{A}, x}^{\mathcal{X}}$ tem complexidade de consulta polilogarítmica se $\lvert x \rvert$ for suficientemente grande.

Então, para cada oráculo $A \subseteq \{0, 1\}^{*}$, considere a seguinte linguagem.

\begin{equation*}
L_{A} = \{1^{w} \lvert \text{Tribes}_{w, s}(A) = 1\},
\end{equation*}

em que $s \approx 2{^w}\ln(2)$. Se $N = ws$, o número de variáveis de entrada de $\Tribes_{w, s}$, então $\Tribes_{w, s}(A)$ siginifica a função $\Tribes_{w, s}$ com o vetor característica de $A^{= \log N}$ em seu argumento. $L_{A} \in \NP^{A}$ para todos $A \subseteq \{0, 1\}^{*}$ pois precisamos apenas verificar que para algum $i$ múltiplo de $w$, $x_{i + 1}, x_{i + 2}, \dots, x_{i + w} \in A$, em que aqui $x_{i}$ é a $i$-ésima string de tamanho $\log N$ na ordem lexicográfica. Como $\log N \approx w + \log w$ também temos que é possível em tempo polinomial escrever cada uma dessas strings na fita de oráculo. Agora podemos provar o teorema \ref{teo: bgs} novamente:

\begin{prop} \label{prop: p_vs_np_r}

Existe um oráculo $A \subseteq \{0, 1\}^{*}$ tal que $L_{A} \notin P^{A}$.

\end{prop}

\begin{proof}

Seja $\{M_{i}\}_{i \geq 1}$ uma enumeração de todas as máquinas de Turing de tempo polinomial, e $\{p_{i}\}_{i \geq 1}$ o tempo de execução das respectivas máquinas de Turing.

Seja $w_{1}, w_{2}, \dots$ uma sequência de números naturais em que $p_{1}(w_{1}) < 2^{w_{1}}$ e para cada $i > 1$ temos que $w_{i} > p_{i - 1}(w_{i - 1})$ e $p_{i}(w_{i}) < 2^{w_{i}}$.

Assim como fizemos na prova original que aparece na seção \ref{section_computational_complexity} nós iremos construir o oráculo $A$ em estágios. Nós descrevemos o $i$-ésimo estágio para algum $i \geq 1$ arbitrário. Inicialmente fazemos $A(0) = \emptyset$ e iremos assumir que no fim do $(i -1)$-ésimo a construção descrita abaixo já obteve o oráculo $A(i - 1)$ definido sobre strings de tamanho no máximo $p_{i - 1}(w_{i - 1})$

Estágio $i$:

Seja $D(i) \subseteq \bigcup_{k \in I_{i}} \binalph^{k}$, em que $I_{i} = \{p_{i - 1}(w_{i - 1}) + 1, p_{i - 1}(w_{i - 1}) + 2, \dots, p_{i}(w^{i}) \} \setminus \binalph^{\log N_{i}}$ e $N_{i} \approx w_{i} + \log w_{i}$~\footnote{Neste ponto nós podemos assumir que $p_{i} = \Omega(n \log n)$ e que $p_{i}(w_{i}) > w_{i} + \log w_{i}$, pois o teorema da hierarquia de tempo determinístico que vimos em \ref{dtime_hierarchy} diz que se nenhuma máquina de Turing que roda em tempo $\Omega(n \log n)$ pode decidir uma linguagem qualquer então certamente nenhuma máquina que roda em tempo $\mathcal{O}(n)$ pode decidir tal linguagem.}. Seja $T_{i}$ a árvore de decisão da computação de $M_{i}$ sobre a entrada $1^{w_{i}}$ com acesso ao oráculo $A(i - 1) \cup D(i)$ em que os nodos da árvore ramificam com consutas à strings em $\binalph^{\log N_{i}}$.  Como $T_{i}$ tem profundidade polilogaritmica e $\Tribes_{N_{i}}$ é evasiva, segue que existe um oráculo $A^{\prime} \subseteq \binalph^{\log N_{i}}$ tal que $T_{i}(A^{\prime}) \neq \Tribes_{N_{i}}(A^{\prime})$. Nós então fazemos $A(i) = A(i - 1) \cup A^{\prime} \cup D(i)$.

Então agora argumentamos que $A = \bigcup_{i \geq 1} A(i)$ satisfaz $\NP^{A} \nsubseteq P^{A}$. Nós iremos assumir que para algum $i \geq 1$ a máquina de Turing $M_{i}$ decide $L_{A}$ com acesso à $A$ em tempo polinomial. Nós fazemos $A^{\prime} = A \cap \binalph^{\log N_{i}}$. Este $A^{\prime}$ apareceu no $i$-ésimo estágio e é tal que $A(i - 1) = A(i) \setminus (A^{\prime} \cup D(i))$. Nós temos o seguinte.

\begin{itemize}

    \item $1^{w_{i}} \in L_{A} \Rightarrow T_{i}(A^{\prime}) = 1 \Rightarrow \Tribes_{N_{i}}(A) = 0 \Rightarrow 1^{w_{i}} \not\in L_{A}$.

    \item $1^{w_{i}} \not\in L_{A} \Rightarrow T_{i}(A^{\prime}) = 0 \Rightarrow \Tribes_{N_{i}}(A) = 1 \Rightarrow 1^{w^{i}} \in L_{A}$.

\end{itemize}

    Ambos os casos são contradições e portanto tal máquina $M_{i}$ não pode existir e $\NP^{A} \nsubseteq P^{A}$.

\end{proof}

Na prova que acabamos de ver nós usamos dois fatos a respeito da função Tribes$_{N}$: 1) ela é evasiva (na verdade só precisamos do fato que Tribes$_{N}$ não pode ser computada por um algoritmo que faz $\Omega(N^{c})$ consultas, para qualquer $c < 1$) e 2) nós podemos verificar que $\Tribes_{N} = 1$ olhando para um número polinomial das variáveis de entrada de $\Tribes_{N}$. Portanto poderiamos substituir Tribes$_{N}$ por qualquer função que satisfaça (1) e (2), como por exemplo a função $Or_{n}$, a disjunção de $n$ variáveis. Porém, a função $Or_{n}$ não é balanceada, o que significa que com probabilidade muito maior do que $1/2$ temos que $Or_{n}(x) = 1$. O problema é que nós iremos precisar de uma função balanceada para provar o resultado da próxima seção.

\section{P $\neq$ NP para oráculos aleatórios} \label{section_p_neq_np_random_oracles}

Um dos objetivos de estudar complexidade relativizada é enteder a relação entres classes de complexidades quando não conseguimos dizer nada de muito útil no mundo não-relativizado. Porém, como já vimos pelo teorema \ref{teo: bgs}, provar que $\P \neq \NP$ para algum oráculo não é nenhuma evidência que $\P \neq \NP$ no mundo não-relativizado, até porque a construção do oráculo $A$ em ambas provas que vimos é só uma especialização do método da diagonalização que por sua vez é basicamente só uma forma de ``trapacear o sistema'' construido uma asserção que codifica a sua própria falsidade. Então, com o objetivo de conseguir algum tipo de evidência que $\P \neq \NP$ poderiamos nos perguntar se é o caso que $\P$ e $\NP$ são diferentes no mundo relativizado típico. E de fato, o próximo teorema é o assunto desta subseção:

\begin{teo} \label{teo: P_NP_random_oracles}

$Pr_{A}[\P^{A} \neq \NP^{A}] = 1$.

\end{teo}

A idéia que teoremas como \ref{teo: P_NP_random_oracles} é evidência que o mesmo resultado que foi provado acontecer quase sempre para oráculos aleatórios também há de ser verdade no mundo não relativizado é conhecido como a hipótese do oráculo aleatório que iremos discutir na seção \ref{section_random_oracle_hypothesis}. Naquela mesma seção iremos ver que a hipótese é falsa.

Antes de ver a prova do teorema \ref{teo: P_NP_random_oracles} nós vamos rapidamente discutir o que queremos dizer por $\P^{A} \neq \NP^{A}$ com probabilidade 1.

\subsubsection{A lei zero-um de Kolmogorov}

Um oráculo aleátorio é gerado incluindo cada $x \in \binalph^{n}$ independentemente com probabilidade 1/2. 


\subsubsection{Prova do teorema \ref{teo: P_NP_random_oracles}}

A idéia principal do teorema \ref{teo: P_NP_random_oracles} é que a função $\Tribes_{w, s} = \Tribes_{N}$ não pode nem mesmo ser aproximada por algoritmos de consulta com complexidade de consulta polilogarítmica.

\begin{prop} \label{prop: tribes_inaproximability}

Seja $A$ qualquer algoritmo de consulta com complexidade de consulta $o(\frac{n}{logn})$, então:

\begin{equation*}
    \Pr_{x \sim \binalphn}[A(x) = \Tribes_{N}(x)] \leq 0,567 
\end{equation*}

\end{prop}

\begin{proof}

É suficiente provar que qualquer algoritmo $A$ que só faz consultas às primeiras $\frac{1}{10}s$ tribos não pode aproximar a função $\Tribes_{N}$. Podemos notar que neste caso o melhor que podemos fazer é fazer $A$ computar a função $\Tribes_{\frac{1}{10}s, w}$. Ou seja, se $g$ é a função computada por $A$, então

\begin{equation*}
	g(x) = 1 \iff \text{pelo menos uma das primeiras } \frac{1}{10}s \text{ tribos é unanimamente 1}.
\end{equation*}

Daí temos que

\begin{equation*}
	\Pr_{x \sim \binalph^{N}}[\Tribes_{N}(x) \neq g(x)] = \E_{x \sim \binalph^{N}}[(\Tribes_{N}(x) - g(x))^{2}].
\end{equation*}

Mas como $\Tribes_{N}(x) \geq g(x)$, para todos $x \in \binalph^{N}$, temos que

\begin{IEEEeqnarray*}{rCl}
	\Pr_{x \sim \binalph^{N}}[\Tribes_{N}(x) \neq g(x)] & = & \E_{x \sim \binalph^{N}}[\Tribes_{N}(x) - g(x)] \\
	                                                                             & = & \E_{x \sim \binalph^{X}}[\Tribes_{N}(x)] - \E_{x \sim \binalphn}[g(x)] \\
	                                                                             & = & 1 - (1 - 2^{-w})^{s} - 1  + (1 - 2^{-w})^{\frac{1}{10}s} \\
	                                                                             & = & (1 - 2^{-w})^{\frac{1}{10}s} - (1 - 2^{-w})^{s}
\end{IEEEeqnarray*}

Com $w$ tendendo ao infinito isso é igual a $2^{-\frac{1}{10}} - 1/2 \approx 0,433$, e portanto

\begin{equation*}
	\Pr_{x \sim \binalph^{N}}[\Tribes_{N}(x) = A(x)] \leq 1 - 0,433 = 0,567.
\end{equation*}

\end{proof}

Então podemos provar o teorema \ref{teo: P_NP_random_oracles}.

\begin{proof} (Prova do teorema \ref{teo: P_NP_random_oracles})

Pela proposição \ref{prop: tribes_inaproximability} nós temos que para uma fração significativa das entradas, $T_{i}(\boldsymbol{A}^{\prime}) \neq Tribes_{N}(\boldsymbol{A}^{\prime})$ e portanto o conjunto $\{A \subseteq \binalph^{*} \lvert \P^{A} \neq \NP^{A}\}$ tem medida positiva.Usando a lei zero-um de Kolmogorov podemos concluir que $\Pr[\P^{\boldsymbol{A}} \neq \NP^{\boldsymbol{A}}] = 1$.

\end{proof}

\section{PH vs PSPACE}

Agora nós generalizamos a idéia que usamos para separar $\P$ e $\NP$ nas seções anteriores para podermos separar $\PSPACE$ e a hierarquia polinomial. Da mesma forma que usamos árvores de decisão para representar $\P$ nós iremos usar circuitos $\AC^{0}$ para representar $\PH$.

Fixe $k \geq 1$. Seja $L \subseteq \binalph^{*}$ uma linguagem em $\Sigma_{k}^{p}$, o que significa que existe uma máquina de Turing $M$ de tempo polinomial tal que para todo $x \in \binalph^{*}$, $x \in L \iff \exists y_{1} \forall y_{2} \dots Q_{k} y_{k} M(x, y_{1}, y_{2}, \dots, y_{k}) = 1$. Fixando ${y}_{1}, y_{2}, \dots, y_{k}$, podemos representar a computação de $M$ sobre $x, {y}_{1}, y_{2}, \dots, y_{k}$ por uma árvore de decisão da forma que vimos anteriormente. Então o circuito $\AC^{0}$ $C_{M, x}^{\mathcal{X}}$ que usamos para representar $L$ tem profundidade $k + 1$ onde cada quantificador $\exists$ é representado por uma camada de portas $\lor$ e $\forall$ é representado por uma camada de portas $\land$, a profundidade é $k + 1$ porque no nível mais baixo nós temos árvores de decisão que podem ser representadas por fórmulas FNC ou FND. Se $N = 2^{n}$ é o número de variáveis de entrada do circuito $C_{M, x}^{\mathcal{X}}$, também vemos que o fan-in das portas no primeiro nível é $\polylog(N)$ e o fan-in nas demais portas é $2^{p(n)}$. O tamanho do circuito é $N^{\polylog(N)}$.

Assim como as árvores de decisão que vimos nas seções \ref{section_alternative_proof_bgs} e \ref{section_p_neq_np_random_oracles}, o circuito $C_{M, x}^{\mathcal{X}}$ satisfaz $C_{M, x}^{\mathcal{X}}(A) = 1 \iff M^{\mathcal{X} \cup A}(x) = 1$, onde nós vemos $A$ como sendo o vetor caratecterísica de um oráculo $A$.

O objetivo desta seção é provar o seguinte teorema.

\begin{teo} \label{teo: pspace_vs_ph_r}

Existe $A \subseteq \binalph^{*}$ tal que $\PSPACE^{A} \neq \PH^{A} = \bigcup_{k \geq 1} \Sigma_{k}^{p, A}$.

\end{teo}

Nós também temos que $\PH^{\TBQF} = \PSPACE^{\TBQF}$, e portanto o teorema \ref{teo: pspace_vs_ph_r} também nós diz que $\PH \text{ vs } \PSPACE$, assim como $\P \text{ vs } \NP$, necessariamente precisa de um argumento que não relativiza. Nós provamos \ref{prop: p_vs_np_r} a partir de um limitante inferior para a função $\Tribes_{N}$. Para provar o teorema \ref{teo: pspace_vs_ph_r} nós iremos usar um limitante inferior para a função paridade de $n$ variáveis.

\begin{defi} (Paridade) \label{parity}

Para $n \geq 1$ a função paridade de $n$ variáveis, que denotaremos por $\Parity_{n}$, é 1 se e se somente se $\sum_{i = 1}^{n} x_{1} \pmod{2} = 1$.

\end{defi}

Consideremos para cada oráculo $A \subseteq \binalph^{*}$ a seguinte linguagem:

\begin{equation*}
    L(A) = \{1^{n} \lvert A(x) = 1 \text{ para um número ímpar de } x \in \binalphn\}.
\end{equation*}

E temos que $L(A) \in \PSPACE^{A}$ já que só precisamos de espaço para escrever cada string de $n$ bits na fita de oráculo mais uma célula para guardar a paridade de $\lvert \{x \in \binalphn \lvert A(x) = 1)\} \rvert$. Uma outra forma de descrever $L$ é dado uma string unária $1^{n}$ e oráculo $A$, então $1^{n} \in L(A) \iff \Parity_{2^{n}}(A^{= n}) = 1$ em que $A^{=n} = A \cap \binalph^{n}$. Nós iremos usar esta caracterização de $L(A)$ mais o teorema \ref{teo: parity_lb} que é enunciado logo abaixo para provar o teorema \ref{teo: pspace_vs_ph_r}.

\begin{teo} \label{teo: parity_lb}

Seja $d > 0$ um inteiro. Para $n$ suficientemente grande temos que qualquer circuito de profundidade $d$ com fan-in $\polylog(n)$ no teu primeiro nível e tamanho $< 2^{\mathcal{O}\big(n^{\frac{1}{d - 1}}\big)}$ não pode computar a função $\Parity_{n}$ corretamente em todas as entradas. 

\end{teo}

Nós iremos provar o teorema \ref{teo: parity_lb} no próximo capítulo (\ref{chapter_random_restrictions_and_projections}) quando formos ver restrições aleatórias e o lema da troca de H{\aa}stad. Na verdade, iremos ganhar de grátis o seguinte teorema.

\begin{teo} \label{teo: parity_lb_app}

Seja $d > 0$ um inteiro. Então, para $n$ suficientemente grande, qualquer circuito com profundidade $d$, fan-in do primeiro nível $\polylog(n)$ que computa $\Parity_{n}$ corretamente numa fração maior do que $1/2 + \Omega(n^{-d})$ das entradas deve ter tamanho maior do que $2^{\Theta\big(n^{\frac{1}{d - 1}}\big)}$.

\end{teo}

E portanto, usando a lei zero-um de Kolmogorv e um argumento semelhante ao que usamos para provar \ref{teo: P_NP_random_oracles}, nós temos o seguinte.

\begin{teo} \label{teo: pspace_vs_ph_random}

$\Pr_{A}[\PSPACE^{A} \neq \PH^{A}] = 1$.

\end{teo}

\begin{proof} (Prova do Teorema \ref{teo: pspace_vs_ph_r})

Nós usamos um argumento parecido com o da prova do teorema \ref{prop: p_vs_np_r}.

Seja $\{M_{i}\}_{i \geq 1}$ uma enumeração de todas as máquinas de Turing de tempo polinomial e $\{p_{i}\}_{i \geq 1}$ o tempo de execução dessas máquinas de Turing. Fixe algum $k \geq 1$ e provaremos que existe $A \subseteq \binalph^{*}$ tal que $\Sigma_{k}^{p, A} \neq \PSPACE^{A}$. Por estarmos escolhendo um $k$ arbitrário, após provarmos que $\Sigma_{k}^{p, A} \neq \PSPACE^{A}$ teremos também provado que $\PH^{A} \neq \PSPACE^{A}$.

Seja $n_{0}$ a constante tal que para todo $n \geq n_{0}$ o resultado do teorema \ref{teo: parity_lb} para circuitos de profundidade $k + 1$ vale -- ou seja, para todo $n \geq n_{0}$ e todo circuito $C$ de profundidade $k + 1$ e tamanho subexponencial existe um $x \in \binalph^{n}$ tal que $C(x) \neq \Parity_{n}(x)$. Nós definimos uma sequência $n_{0}, n_{1}, n_{2}, \dots$ de números naturais tais que para todo $i \geq 1$ é verdade que $n_{i} > p_{i - 1}(n_{i - 1})$ e $p_{i}(n_{i}) < 2^{n_{i}}$.

Nós construimos $A$ em estágios e descreveremos o $i$-ésimo estágio para algum $i \geq 1$ arbitrário. Seja $A(0) = \emptyset$.

Estágio $i$:

Seja $D(i) \subseteq \bigcup_{k \in I_{i}} \binalph^{k}$ algum oráculo arbitrário onde $I_{i} = \{p_{i - 1}(n_{i - 1}) + 1, p_{i - 1}(n_{i - 1}) + 2, \dots, p_{i}(n_{i}) \} \setminus \binalph^{n_{i}}$. Seja $C_{i}$ o circuito da computação de $M_{i}$ sobre a entrada $1^{n_{i}}$ e com acesso ao oráculo $A(i - 1) \cup D(i)$ e que faz consultas à strings em $\binalph^{n_{i}}$. Pelo teorema \ref{teo: parity_lb} deve haver um oráculo $A^{\prime} \subseteq \binalph^{n_{i}}$ tal que $C_{i}(A^{\prime}) \neq \Parity_{2^{n_{i}}}(A^{\prime})$. Então fazemos $A(i) = A(i - 1) \cup A^{\prime} \cup D(i)$.

Argumentaremos que $A = \bigcup_{i = 1}^{\infty}A(i)$ satisfaz $L(A) \not\in \Sigma_{k}^{p, A}$. Suponha que uma máquina de Turing de tempo polinomial $M_{i}$ decida $L(A)$ com $k$ quantificadores alternantes e com acesso a $A$. Seja $A^{\prime}$ o oráculo que apareceu no $i$-ésimo estágio que é tal que $A(i - 1) = A(i) \setminus (A^{\prime} \cup D(i))$. Note que também é verdade que $A \cap \binalph^{n_{i}} = A^{\prime}$. Então nós temos o seguinte.

\begin{itemize}

    \item $1^{n_{i}} \in L(A) \Rightarrow C_{i}(A^{\prime}) = 1 \Rightarrow \Parity_{2^{n_{i}}}(A^{\prime}) = 0 \Rightarrow 1^{n_{i}} \not\in L(A)$.

    \item $1^{n_{i}} \not\in L(A) \Rightarrow C_{i}(A^{\prime}) = 0 \Rightarrow \Parity_{2^{n_{i}}}(A^{\prime}) = 1 \Rightarrow 1^{n_{i}} \in L(A)$.

\end{itemize}

Ambos os casos são contradições e portanto não existe tal máquina de Turing de tempo polinomial que decida $L(A)$ com $k$ quantificadores alternantes. Como $L(A) \in \PSPACE^{A}$ podemos concluir que $\Sigma_{k}^{p, A} \neq \PSPACE^{A}$.

\end{proof}



\section{Separando a hierarquia polinomial} \label{section_separating_PH}

Como vimos na seção anterior, podemos representar $\Sigma_{k}^{p}$ por circuitos $\AC^{0}$ com profundidade $k + 1$. Portanto, se queremos provar que existe $A \subseteq \binalph^{*}$ tal que $\Sigma_{k}^{p, A} \not\subseteq \Sigma_{k - 1}^{p. A}$ nós temos que demonstrar a existência de uma ''hierarquia de profundidade``. O que queremos dizer é que deve existir para cada $k > 1$ uma função $f_{k}$ tal que existe um circuito de tamanho polinomial e profundidade $k + 1$ que computa $f_{k}$ mas que qualquer circuito com profundidade $k$ que computa $f_{k}$ tem tamanho exponencial. Note que pelo teorema \ref{teo: parity_lb} a função paridade não pode ser computada por circuitos $\AC^{0}$ de tamanho polinomial e profundidade $k$ para \emph{todas} as constantes $k \geq 1$ e portanto temos que provar limites inferior para funções diferentes da função paridade. Para este fim define-se as funções de Sipser:

\begin{defi} (As funções de Sipser) \label{Sipser_f}

Para $d \geq 2$ a função de Sipser $f^{m, d}$ é uma fórmula monotônica e \emph{read-once}~\footnote{Nós dizemos que um circuito ou fórmula é \emph{read-once} se cada variável de entrada só alimenta uma única porta lógica.} onde o nível mais baixo tem fan-in $m$, as portas lógicas nos níveis 2 até d - 1 têm fan-in $w = 2^{m}m \ln(2)$ e a porta lógica no nível mais alto tem fan-in $w_{d} \approx 2^{m} ln(2)$. Ou seja, podemos escrever $f^{m, d}$ como

\begin{equation} \label{Sipser_f_defi_1}
	\bigvee_{i_{d}  = 1}^{w_{d}}\bigwedge_{i_{d - 1} = 1}^{w} \dots \bigvee_{i_{2} = 1}^{w} \bigwedge_{i_{1} = 1}^{m} x_{i_{1}, i_{2}, \dots, i_{d}}, \text{ se } d \text{ é par.}
\end{equation}

e

\begin{equation} \label{Sipser_f_defi_2}
	\bigwedge_{i_{d}  = 1}^{w_{d}}\bigvee_{i_{d - 1} = 1}^{w} \dots \bigvee_{i_{2} = 1}^{w} \bigwedge_{i_{1} = 1}^{m} x_{i_{1}, i_{2}, \dots, i_{d}}, \text{ se } d \text{ é ímpar.}
\end{equation}

\end{defi}

Segue direto da definição que o número $n$ de variáveis de entrada da função $f^{m, d}$ é simplesmente o produto dos fan-ins de cada nível.

\begin{equation*}
	n = mw^{d - 2}w_{d} = \Theta(w^{d - 1}).
\end{equation*}

E portanto também temos que $w = \Theta(n^{\frac{1}{d - 1}})$.

Segue também pela definição de $f^{m, d}$ exposta em \ref{Sipser_f_defi_1} e \ref{Sipser_f_defi_2} que ela pode ser computada por um circuito de profundidade $d$ e tamanho

\begin{equation*}
	S = 1 + \frac{n}{m}\sum_{i = 0}^{d - 2} n^{i} = 1 + \frac{n}{m}\Big(\frac{w^{d - 1} - 1}{w - 1}\Big) = \widetilde{\Theta}(n^{2 - \frac{1}{d - 1}}),
\end{equation*}

Agora o resultado que nós precisamos para separar cada nível da hierarquia polinomial relativa à um oráculo segue do seguinte resultado, que também foi provado pela primeira vez por Håstad em sua tese de doutorado.

\begin{teo} \label{Sipser_f_lb}

Seja $d > 2$ e $m$ suficientemente grande, qualquer circuito de tamanho no máximo $2^{w^{1/5}}$ e profundidade $d - 1$ não computa a função $f^{m, d}$ corretamente em todas as entradas.

\end{teo}

Como $w = \Theta(n^{\frac{1}{d - 1}})$, o teorema \ref{Sipser_f_lb} nos dá um limitante inferior de $2^{n^{\Omega \big(\frac{1}{d - 1} \big)}}$ para o tamanho de qualquer circuito de profundidade $d - 1$ que computa a função $f^{m, d}$. De novo, deixaremos a prova do teorema \ref{Sipser_f_lb} para o próximo capítulo, por enquanto só estamos preocupados na seguinte aplicação deste teorema.

\begin{teo} \label{ph_no_collapse_r}
Existe um oráculo $A \subseteq \binalph^{*}$ tal que para todo $k \geq 2$, $\Sigma_{k}^{p, A} \neq \Sigma_{k - 1}^{p, A}$.
\end{teo}

Ou seja, para este oráculo $A$, $\PH^{A} \neq \Sigma_{k}^{p, A}$, para todos $k \geq 1$. Logo, em particular, $\NP^{A} \neq \PH^{A} \Rightarrow \P^{A} \neq \NP^{A}$, então podemos ver a prova do teorema \ref{ph_no_collapse_r} como a terceira prova do teorema de Baker-Gill-Solovay em \ref{teo: bgs} e \ref{prop: p_vs_np_r} que iremos ver, mas desta vez também estaremos provando algo bem mais forte usando uma estratégia parecida. Nós na verdade iremos provar que existe um oráculo $A$ tal que para todo $k \geq 2$ é verdade que $\Pi_{k}^{p, A} \neq \Pi_{k - 1}^{p, A}$, mas como observamos ainda na seção \ref{section_computational_complexity}, é verdade que $\bigcup_{k \geq 1} \Sigma_{k}^{p, A} = \bigcup_{k = 1} \Pi_{k}^{p, A} = \PH^{A}$. 

Para cada $k \geq 1$ nós definimos a linguagem $L_{k}(A) = \{1^{m} \lvert f^{m, k + 1}(A) = 1\}$, em que neste caso as variáveis de entrada de $f^{m, k + 1}$ são $A(x)$ para cada string de $x$ de uma tamanho $\lvert x \rvert = \log n$ fixo em que $n \approx (d - 1)(m + \log m)$. Nós podemos notar que $L_{k}(A) \in \Pi_{k}^{p, A}$ pois podemos usar $k$ quantificadores alternantes para simular as diferentes camadas do circuito e depois disso tudo que precisamos fazer é  uma quantidade linear de consultas à $A$ para achar o valor de uma porta $\land$ no nível mais baixo. Para provar que existe um oráculo $A$ tal que $\Pi_{k}^{p, A} \neq \Pi_{k - 1}^{p, A}$ nós iremos provar a asserção mais forte que diz que existe um oráculo $A$ tal que $L_{k}(A) \not\in \Pi_{k - 1}^{p, A}$.

\begin{proof} (Prova do Teorema \ref{ph_no_collapse_r})

Nós agora iremos enumerar predicados $\PH$ que são predicados $P$ da forma

\begin{equation*}
    P(x) \iff \forall z_{1} \exists z_{2} \forall \dots Q_{k} z_{k} M(x, z_{1}, z_{2}, \dots, z_{k}),
\end{equation*}

em que $M$ é uma máquina de Turing de tempo polinomial. Seja $\{P_{i}\}_{i \geq 1}$ uma enumeração dos predicados $\PH$ e $\{p_{i}\}_{i \geq 1}$ é o tempo de execução de cada máquina de Turing na definição dos predicados $\PH$.

Nós então consideramos uma sequência $m_{0}, m_{1}, m_{2}, \dots$ de números naturais em que $m_{0}$ é grande o suficiente para satisfazer o resultado do teorema \ref{Sipser_f_lb} e para todo $i \geq 1$ temos que $m_{i} > p_{i -1}(m_{i - 1})$ e $p_{i}(m_{i}) < 2^{m_{i}}$. Para cada $m_{i}$ nós teremos um outro número natural $n_{i}$ que seria o número de variáveis de entrada da função $f^{m_{i}, k + 1}$ em que $k$ é tal que $P_{i}$ é um predicado $\PH$ com $k - 1$ quantificadores alternantes.

Como fizemos em todas as provas de resultados deste tipo, nós iremos construir o oráculo $A$ em estágios e descreveremos o $i$-ésimo estágio, para algum $i \geq 1$ arbitrário. Inicialmente nós fazemos $A(0) = \emptyset$.

Estágio $i$:

Seja $k \geq 2$ tal que $P_{i}$ é um predicado $\PH$ com $k - 1$ quantificadores alternantes. Seja $D(i) \subseteq \bigcup_{l \in I_{i}} \binalph^{l}$ um oráculo arbitrário em que $I_{i} = \{p_{i - 1}(m_{i - 1}) + 1, p_{i - 1}(m_{i - 1}) + 2, \dots, p_{i}(m_{i})\} \setminus \binalph^{\log n_{i}}$~\footnote{Agora temos que $\log n_{i} \approx (k - 1)(m_{i} + \log m_{i})$ mas podemos de novo assumir que todo polinômio $p_{i}$ é $\Omega(n \log n)$ sem perda de generalidade.}. Seja $C_{i}$ o circuito da computação de $P_{i}$ sobre a entrada $1^{m_{i}}$ com $k - 1$ quantificadores alternantes e acesso ao oráculo $A(i - 1) \cup D(i)$. Ou seja, $C_{i}$ é um circuito de profundidade $k$ com tamanho quasipolinomial~\footnote{Quasipolinomial significa funções da forma $n^{\log^{c} n}$ para $c > 0$.} e fan-in polilogaritmico no seu nível mais baixo e

\begin{equation*}
    C_{i}(A^{\prime}) = 1 \iff \forall z_{1} \exists z_{2} \forall \dots Q_{k - 1} z_{k - 1} M_{i}^{A(i - 1) \cup D(i) \cup A^{\prime}}(1^{m_{i}}, z_{1}, z_{2}, \dots, z_{k - 1}) = 1.
\end{equation*}

Então, pelo teorema \ref{Sipser_f_lb} deve haver um oráculo $A^{\prime} \subseteq \binalph^{\log n_{i}}$ tal que $C_{i}(A^{\prime}) \neq f^{m, k + 1}(A^{\prime})$. Nós então fazemos $A(i) = A^{\prime} \cup D(i)$.

Agora suponha que existe um $k \geq 1$ e um predicado $\PH$ $P_{i}$ com $k$ quantificadores alternantes tal que $P_{i}(x) \iff x \in L_{k}(A)$. Nós então consideramos o oráculo $A^{\prime} = A \cap \binalph^{\log n_{i}}$. Nós temos o seguinte

\begin{itemize}

	\item $1^{m_{i}} \in L_{k}(A) \Rightarrow C_{i}(A^{\prime}) = 1 \Rightarrow f^{m_{i}, k + 1}(A^{\prime}) = 0 \Rightarrow 1^{m_{i}} \not\in L_{k}(A)$.
	
	\item $1^{m_{i}} \not\in L_{k}(A) \Rightarrow C_{i}(A^{\prime}) = 0 \Rightarrow f^{m_{i}, k + 1}(A^{\prime}) = 1 \Rightarrow 1^{m_{1}} \in L_{k}(A)$.

\end{itemize}

Ambos os casos são contradições.

\end{proof}

\subsubsection{Separando a hierarquia polinomial com oráculos aleatórios}

Recentemente, Rossman, Servedio e Tan (referência) provaram uma versão do teorema \ref{Sipser_f_lb} para o caso médio. Ou seja, eles mostraram que as funções de Sipser da forma que estamos definindo elas neste texto nos dão uma hierarquia de circuitos de profundidade constante até mesmo no caso médio em que nós permitimos que circuitos de profundidade $d - 1$ apenas aproximem circuitos de tamanho polinomial e profundidade $d$. Ou seja, o teorema \ref{Sipser_f_lb} nos diz que circuitos de tamanho subexponencial e profundidade $d - 1$ não são capazes de computar $f^{m, d}$ corretamente em todas as entradas. O teorema que iremos enunciar logo em seguida vai além e diz que circuitos de tamanho subexponencial e profundidade $d -1$ nem sequer podem aproximar $f^{m, d}$.

\begin{teo} \label{Sipser_f_lb_app}

Seja $d > 2$ e $m$ suficientemente grande, então qualquer circuito de tamanho $S \leq 2^{w^{1/5}}$ e profundidade $d - 1$ falha em computar a função $f^{m, d}$ corretamente numa fração maior do que $1/2 + n^{-\Omega(1/d)}$ das entradas.

\end{teo}

\begin{teo} \label{np_vs_sigma2_r}
	$\Pr_{A \sim \binalph^{*}}[\NP^{A} \neq \Sigma_{2}^{p, A}] = 1$.
\end{teo}

E o teorema \ref{np_vs_sigma2_r} segue do seguinte limite inferior para uma fórmula FNC que aproxima uma variação da função $\Tribes$.

\begin{defi} (Dual da função $\Tribes$)

O dual da função $\Tribes_{w, s}$ é a função $\Tribes_{w, s}^{\dagger}$ definida como

\begin{equation*}
	\Tribes_{w, s}^{\dagger}(x_{1, 1}, x_{1,2}, \dots, x_{s, w})  = \overline{\Big(\bigvee_{i = 1}^{s}\bigwedge_{j = 1}^{w} \overline{x}_{i, j}\Big)} = \overline{\Tribes_{w, s}(\overline{x}_{1, 1}, \overline{x}_{1, 2}, \dots, \overline{x}_{s, w})}.
\end{equation*}

\end{defi}

E então provaremos o seguinte teorema.

\begin{teo} (O'Donnell, Wimmer) \label{odonnell_wimmer}

Seja $F_{m} = \Tribes_{b, 2^{b}} \lor \Tribes_{b, 2^{b}}^{\dagger}$, então qualquer circuito FNC (ou FND) $C$ que  0,04-aproxima $f$ deve ter tamanho $s = 2^{\Omega(n/\log n)}$.

\end{teo}

Como $f$ pode ser computada por um circuito de tamanho polinomial e profundidade 3, o teorema \ref{np_vs_sigma2_r} segue diretamente de \ref{odonnell_wimmer}.

Para provar o teorema \ref{odonnell_wimmer} nós precisaremos de algumas observações. Caso quisermos computar a função $\Tribes_{b, 2^{b}}$ nós precisamos apenas saber o valor de cada tribo. Ou seja, sejam $\{y_{i}\}_{i = [2^{b}]}$ variáveis, nós podemos ``projetar'' as variáveis $\{x_{i, j}\}_{j \in [b]}$ para a variável $y_{i}$ de forma que $y_{i} = \bigwedge_{j = 1}^{b} x_{i, j}$, o que denotaremos por $(y \lvert x)$, e então podemos ver $\Tribes_{b, 2^{b}}$ como a disjunção das variáveis $y_{i}$. Considere então uma fórmula FNC $F$ que $\varepsilon$-aproxima a função $\Tribes_{b, 2^{b}}$ e que tenha tamanho $s$ e cada cláusula tenha largura no máximo $w$, e considere também uma cláusula $C$ qualquer de $F$ e troque cada aparição da variável $x_{i, j}$ em $C$ por $(x_{i, j} \lor y_{i})$ e cada aparição de $\overline{x}_{i, j}$ por $\overline{(x_{i, j} \lor y_{i})}$ e chame a disjunção resultante de $C^{\prime}$. Podemos argumentar que $C^{\prime}$ é equivalente à $C$ pois $(x_{i, j} \lor y_{i})$ é sempre igual a $x_{i, j}$. Então, se $F_{1}$ for a fórmula FNC construida a partir de $F$ da forma que acabamos de descrever (a conjunção das novas cláusulas $C^{\prime}$) temos que $F_{1}$ e $F$ são equivalente, e daí segue que

\begin{equation*}
	\Pr_{x, (y \lvert x)}[F_{1}(x, y) \neq \Tribes_{b, 2^{b}}(x)] < \varepsilon
\end{equation*}

Mas ao invés de construir $y$ a partir de $x$ podemos também construir $x$ a partir de $y$ sem mudar a distribuição de pares $(x, y)$ da seguinte maneira:

\begin{enumerate}

	\item Para cada $i \in [2^{b}]$, faça $y_{i} = 0$ com probabilidade $1 - 2^{-b}$ e $y_{i} = 1$ com probabilidade $2^{-b}$.
	
	\item Para cada $i \in [2^{b}]$ e $j \in [b]$, faça $x_{i, j} = 1$ se $y_{i} = 1$, e $(x_{i, 1}, \dots, x_{i, b})$ tirada da distribuição uniforme sobre $\binalph^{b} \setminus (1, 1, \dots, 1)$ se $y_{i} = 0$. 

\end{enumerate}

Denotamos a string $x$ construida a partir de $y$ por $(x \lvert y)$, e então:

\begin{equation*}
	\E_{y}\Big[\Pr_{(x \lvert y)}[F_{1}(x, y) \neq \Tribes_{b, 2^{b}}(x)]\Big] < \varepsilon
\end{equation*}

Agora, note que dado que $y_{i}$ = 1 os valores de $x_{i, j}$ são meio que redudantes, então podemos trocar as strings $(x_{i, 1}, \dots, x_{i, b})$ por uma string $z_{i}$ tirada da distribuição uniforme sobre $\binalph^{b} \setminus (1, 1, \dots, 1)$, independente de $y$. Seja $g(y) = \bigvee_{i = 1}^{2^{b}}y_{i}$ que é equivalente à $\Tribes_{b, 2^{b}}(x)$. Então, temos o seguinte:

\begin{equation*}
	\E_{y}\Big[ \Pr_{z}[F_{1}(z, y) \neq g(y)]\Big] < \varepsilon
\end{equation*}

e por $z$ e $y$ serem independentes:

\begin{equation*}
	\E_{z}\Big[\Pr_{y}[F_{1}(z, y) \neq g(y)]\Big] < \varepsilon
\end{equation*}

E portanto deve existir um $z^{*} \in \binalph^{b}$ tal que

\begin{equation*}
	\Pr_{y}[F_{1}(z^{*}, y) \neq g(y)] < \varepsilon.
\end{equation*}

E definimos a fórmula FNC $F^{\prime}$ como $F^{\prime}(y) = F_{1}(z^{*}, y)$. O que podemos tirar de tudo isso é que aproximar $\Tribes_{b, 2^{b}}$ por fórmulas FNC é pelo menos tão difícil quanto aproximar a função $g$ sobre as variáveis $\{y_{i}\}_{i \in [2^{b}]}$. Agora nós podemos provar um limite inferior para a largura de um circuito FNC que aproxima a função $\Tribes_{b, 2^{b}}$.

\begin{teo} \label{tribes_width_lb}

Seja $m = b2^{b}$ o número de variáveis de entrada da função $\Tribes_{b, 2^{b}}$ e seja $C$ um circuito FNC que 0,2-aproxima esta função com largura $w$. Então devemos ter $w \geq (1/3)2^{b} = \Omega(m/\log m)$.

\end{teo}

\begin{proof}

Vamos considerar o circuito $C^{\prime}$ sobre as variáveis $\{y_{i}\}_{i \in [2^{b}]}$ análogo à fórmula $F^{\prime}$ que acabamos de descrever. $C^{\prime}$ 0,2-aproxima a função $g(y) = \bigvee_{i = 1}^{2^{b}} y_{i}$ e tem largura $w^{\prime} \leq w$ e portanto provar que $w^{\prime} \geq (1/3)2^{b}$ é suficiente para provar o teorema.

Vamos primeiro assumir que todas as cláusulas de $C^{\prime}$ tenha uma variável negada. Neste caso a entrada $(0, 0, \dots, 0)$ faz $C^{\prime}$ avaliar para 1 enquanto que $g(0, 0, \dots, 0) = 0$, e portanto

\begin{equation*}
	\Pr_{y}[C^{\prime}(y) \neq g(y)] \geq \Pr_{y}[y = (0, 0, \dots, 0)] = (1 - 2^{-b})^{2^{b}} = 1/e > 1/4 > 0,2,
\end{equation*}

contradizendo a nossa hipótese. Portanto, deve haver uma cláusula que consiste somente de literais positivos e a probabilidade que esta cláusula é verdadeira é no máximo $w^{\prime}2^{-b}$, com isto dito:

\begin{equation*}
	\Pr_{y}[C^{\prime}(y) = 0] \geq 1 - w^{\prime}2^{-b}.
\end{equation*}

E como $C^{\prime}$ 0,2-aproxima a função $g$ devemos ter $1 - w^{\prime}2^{-b} \leq 1/e + 0,2 \Rightarrow w^{\prime} \geq (0,8 - 1/e)2^{b} \geq (1/3)2^{b}$.

\end{proof}

Note que por dualidade, o mesmo limite inferior vale para a função $\Tribes_{b. 2^{b}}^{\dagger}$.

\begin{cor} \label{tribes_dagger_width_lb}

Seja $C$ um circuito FNC que 0,2-aproxima a função $\Tribes_{b, 2^{b}}^{\dagger}$ com largura $w$. Então devemos ter $w \geq (1/3)2^{b} = \Omega(m/ \log m)$.

\end{cor}

Agora podemos provar o teorema \ref{odonnell_wimmer}.

\begin{proof} (Prova do teorema \ref{odonnell_wimmer})

Primeiro nos consideraremos o caso que o circuito $C$ está na FND. Por (...) sabemos que existe um circuito FND de largura $\log(100s)$ que $0,04 + 1/100 = 0,05$-aproxima $F_{m}$. Seja $x \sim \Tribes_{b, 2^{b}}^{-1}(0)$ e $y \sim \binalph^{m}$. Então temos que

\begin{IEEEeqnarray*} {rCl}
	\Pr_{x \sim \Tribes_{b, 2^{b}}^{-1}(0), y}[C(x, y) \neq F_{m}(x, y)] & = & \Pr_{x, y}[C(x, y) \neq F_{m}(x, y) \big\vert x \in \Tribes_{b, 2^{b}}^{-1}(0)] \\
	                                                                                                                 & = & \frac{\Pr_{x, y}[C(x, y) \neq F_{m}(x, y) \land x \in \Tribes_{b, 2^{b}}^{-1}(0)]}{\Pr_{x}[x \in \Tribes_{b, 2^{b}}^{-1}(0)]} \\
	                                                                                                                 & \leq & 4\Pr_{x, y}[C(x, y) \neq F_{m}(x, y)] \\
	                                                                                                                 &  \leq & 4\times 0,05 = 0,2.
\end{IEEEeqnarray*}

Donde nós usamos o fato que $\Pr[a \land b] \leq \Pr[a]$, para quaisquer eventos $a$ e $b$, e também que pelo menos uma fração de $1/4$ das strings $x \in \binalph^{m}$ fazem a função $\Tribes_{b, 2^{b}}(x) = 0$ na primeira desigualdade.

Mas quando $\Tribes_{b, 2^{b}}(x) = 0$, $F_{m}(x, y)$ é simplesmente $\Tribes_{b, 2^{b}}^{\dagger}(y)$. Então podemos fixar um $x^{*}$ tal que

\begin{equation*}
	\Pr_{y \sim \binalph^{m}}[C(x^{*}, y) \neq \Tribes_{b, 2^{b}}^{\dagger}(y)] < 0,2.
\end{equation*}

Seja $C^{\prime}$ o circuito tal que $C^{\prime}(y) = C(x^{*}, y) = \Tribes_{b, 2^{b}}^{\dagger}(y)$. Como a largura de $C^{\prime}$ é no máximo $\log(100s)$, pelo corolário \ref{tribes_dagger_width_lb} devemos ter

\begin{IEEEeqnarray*} {rCl}
	\log(100s) & \geq & (1/3)2^{b} \\
	100s         & \geq & 2^{(1/3)2^{b}} \\
	s               & \geq & 2^{(1/3)2^{b}}/100.
\end{IEEEeqnarray*}

E como $2^{(1/3)2^{b}}/100 = 2^{\Omega(m/\log m)}$, nós completamos a prova para o caso em que $C$ é um circuito FND. No caso em que $C$ é um circuito FNC nós meio que trocamos o papel das funções $\Tribes_{b, 2^{b}}$ e $\Tribes_{b, 2^{b}}^{\dagger}$ e usamos os mesmos argumentos.

\end{proof}

Só como um comentário, o argumento que O'Donnell e Wimmer usaram para provar o teorema \ref{tribes_width_lb} é basicamente um dos últimos passos que (...) usaram para provar (...). Lembrando que eles queriam mostrar que a função $\Sipser^{\prime}_{d}$ não pode ser aproximada por circuitos de profundidade $d - 1$ e tamanho subexponencial. A estratégia deles foi definir um operador $\Psi$ de forma que com alta probabilidade $\Psi(\Sipser^{\prime})$ pode ser representada como $Or_{S}$, o ``ou'' sobre variáveis $\{y_{i}\}_{i \in S}$, enquanto que $\Psi(C)$ é representada por um uma fórmula FNC com largura ``pequena'' sobre as mesmas variáveis $\{y_{i}\}_{i \in S}$ e portanto não pode ser o caso que $C$ esteja perto de $\Sipser^{\prime}$.

\section{A hipótese dos oráculo aleatório} \label{section_random_oracle_hypothesis}