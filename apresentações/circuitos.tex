\documentclass[landscape, 9pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}

\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{latexsym}
\usepackage{complexity}
\usepackage{bbm}

\usepackage[retainorgcmds]{IEEEtrantools}

\usepackage{hyperref}

\usepackage{xcolor}

\usepackage{tikz}
\usetikzlibrary{arrows,positioning}
\usetikzlibrary{shapes.geometric}

\newtheorem{teo}{Teorema}
\newtheorem{defi}[teo]{Definição}
\newtheorem{lema}[teo]{Lema}
\newtheorem{cor}[teo]{Corolário}
\newtheorem{prop}[teo]{Proposição}
\newtheorem{fato}[teo]{Fato}
\newtheorem*{clique}{CLIQUE}
\newtheorem*{maxclique}{MAX-CLIQUE}
\newtheorem*{ETH}{Hipótese do tempo exponencial}
\newtheorem*{SETH}{Hipótese do tempo exponencial forte}
\newtheorem*{NAEtest}{Teste NAE}
\newtheorem*{NAEplusBLRtest}{Teste NAE+BLR}
\newtheorem*{dicttest}{Teste para subconjuntos de funções ditadores}

%newcommands

\newcommand{\binalph}{\{0, 1\}}
\newcommand{\binalphn}{\binalph^{n}}
\newcommand{\pmone}{\{-1, 1\}}
\newcommand{\pmonen}{\pmone^{n}}
\newcommand{\uniE}{\E_{x \sim \pmonen}}
\newcommand{\UniE}{\underset{x \sim \pmonen}{\E}}
\newcommand{\uniPr}{\Pr_{x \sim \pmonen}}
\newcommand{\Size}{\text{Size}}
\newcommand{\degg}{\text{deg}}
\newcommand{\I}{\mathrm{I}}
\newcommand{\Stab}{\text{Stab}}
\newcommand{\Tribes}{\text{Tribes}}
\newcommand{\Majority}{\text{Majority}}
\newcommand{\Parity}{\text{Parity}}
\newcommand{\supp}{\text{supp}}
\newcommand{\dist}{\text{dist}}
\newcommand{\sgn}{\text{sgn}}
\newcommand{\BLR}{\text{BLR}}
\newcommand{\NAE}{\text{NAE}}
\newcommand{\NAEplusBLR}{\text{NAE+BLR}}

\mathchardef\mhyphen="2D

%newlangs

\newlang{\HALT}{HALT}
\newlang{\UHALT}{UHALT}
\newlang{\CLIQUE}{CLIQUE}
\newlang{\MAXCLIQUE}{MAX\mhyphen CLIQUE}
\newlang{\CIRCUITEVAL}{CIRCUIT\mhyphen EVAL}
\newlang{\CIRCUITSAT}{CIRCUIT\mhyphen SAT}
\newlang{\TBQF}{TBQF}

%newclasses

\newclass{\DEPTH}{DEPTH}
\newclass{\Puniform}{\P\mhyphen uniforme}
\newclass{\loguniform}{logspace\mhyphen uniforme}

%newfunctions

\newfunc{\subexp}{subexp}
\newfunc{\Sipser}{Sipser}

\tikzset{
	treenode/.style = {align=center, inner sep=0pt, text centered, font=\sffamily, size=1cm},
	c_node/.style = {circle, draw, scale=.7, black},
	c_node2/.style = {circle, draw, scale=.4, black},
	s_node/.style = {draw, scale=.7, black},
	s_node2/.style = {draw, scale=.4, black},
	v_node/.style = {scale=.7, black},
	g_node/.style = {circle, draw, scale=.5, black},
	o_node/.style = {ellipse, draw, scale=.5, black},
	t_node/.style = {scale=.5},
	dots_node/.style = {scale=.8},
	r_edge/.style = {red!100},
	b_edge/.style = {black},
	triangle/.style = {fill=blue!20, regular polygon, regular polygon sides=3},
           border rotated/.style = {shape border rotate=180},
           dt_node/.style = {triangle, border rotated, draw, scale=1.4},
}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}

\titlepage

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Fórmulas FNC e FND}

Uma fórmula FNC $F$ sobre as variáveis $x_{1}, \dots, x_{n}$ é a conjunção de disjunções de literais (uma das variáveis ou a tua negação).

\begin{equation*}
	F = C_{1} \land \dots \land C_{s}
\end{equation*}

Onde cada cláusula $C_{i}$ é a disjunção de literais e $s$ é o tamanho de $F$.

Se cada clásula tem no máximo $k$ literais então dizemos que $F$ tem largura $k$ e dizemos que $F$ é uma $k$-FNC.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Fórmulas FNC e FND}

Uma fórmula FND $F$ por outro lado é a disjunção de conjuções de literais.

\begin{equation*}
	F = T_{1} \lor \dots \lor T_{s}
\end{equation*}

Onde cada termo $T_{i}$ é a conjunção de literais e $s$ é o tamanho de $F$.

De novo, se cada termo tem no máximo $k$ literais então $F$ tem largura $k$ e $F$ é uma $k$-FND.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Árvores de decisão}

Uma árvore de decisão é algo como a imagem abaixo:

\begin{center}
\begin{tikzpicture}[->, scale=.7, level/.style={sibling distance=60mm/#1, level distance = 1.3cm}]  

	\node [c_node] (root) {$x_{1}$}
		child { node [c_node] (n0) {$x_{2}$}
			child { node [s_node] (n00) {0} edge from parent node [above, scale=.7] {0}}
			child { node [c_node] (n01) {$x_{3}$}
				child { node [s_node] (n010) {0} edge from parent node [above, scale=.7] {0}}
				child {node [s_node] (n011) {1} edge from parent node [above, scale=.7] {1}}
				edge from parent node [above, scale=.7] {1}
			}
			edge from parent node [above, scale=.7] {0}
                     }
		child{ node [c_node] (n1) {$x_{2}$}
			child{ node [c_node] (n10) {$x_{3}$}
				child { node [s_node] (n100) {0} edge from parent node [above, scale=.7] {0}}
				child { node [s_node] (n101) {1} edge from parent node [above, scale=.7] {1}}
				edge from parent node [above, scale=.7] {0}
			}
			child{ node [s_node] (n11) {1} edge from parent node [above, scale=.7] {1}}
			edge from parent node [above, scale=.7] {1}
		};
	
\end{tikzpicture}
\end{center}

\begin{itemize}

	\item Cada nodo leva o label de uma das variáveis.
	
	\item Começando do nodo mais alto, o algoritmo ramifica para a direita ou à esquerda dependendo do valor da variável lida.
	
	\item As folhas guardam o valor da função em cada entrada que chega nela.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Árvores de decisão}

Denotamos a sáida de uma árvore de decisão $T$ sobre a entrada $x$ por $T(x)$. Se $f$ é tal que $f(x) = T(x)$ para todos os $x$ então dizemos que $T$ computa a função $f$.

\begin{itemize}

	\item Por exemplo, a árvore de decisão do slide anterior computa a função que $\Majority_{3}$, que é 1 se e somente se o número de 1s na entrada é pelo menos 2.

\end{itemize}

O tamanho de $T$ é o número de folhas e tua profundidade é o maior camnho do nodo mais alto até uma das folhas.

\begin{itemize}

	\item A árvore do slide anterior tem tamanho 6 e profundidade 3.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Árvores de decisão}

É importante notar que árvores de decisão são mais fracas do que fórmulas FNC (FND).

\begin{itemize}

	\item Se $T$ é uma árvore de decisão de tamanho $s$ e profundidade $d$ então existe uma fórmula FND (FNC) $F$ tal que  $F(x) = T(x)$, para todos $x$, de tamanho $\leq s$ e largura $\leq d$.
	
	\begin{itemize}

		\item FND: Cada caminho $P$ da árvore tal que $T(P) = 1$ define uma cláusula.

		\item FNC: Cada caminho $P$ da árvore tal que $T(P) = 0$ define um termo.
	
	\end{itemize}

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} [fragile] {Árvores de decisão}

É importante notar que árvores de decisão são mais fracas do que fórmulas FNC (FND).

\begin{center}
\begin{tikzpicture}[->, scale=.7, level/.style={sibling distance=60mm/#1, level distance = 1.3cm}]

	\node [c_node] (root) {$x_{1}$}
		child { node [c_node] (n0) {$x_{2}$}
			child { node [s_node] (n00) {0} edge from parent [b_edge] node [above, scale=.7] {0}}
			child { node [c_node] (n01) {$x_{3}$}
				child { node [s_node] (n010) {0} edge from parent [b_edge] node [above, scale=.7] {0}}
				child {node [s_node] (n011) {1} edge from parent [r_edge] node [above, scale=.7] {1}}
				edge from parent [r_edge] node [above, scale=.7] {1}
			}
			edge from parent [r_edge] node [above, scale=.7] {0}
                     }
		child{ node [c_node] (n1) {$x_{2}$}
			child{ node [c_node] (n10) {$x_{3}$}
				child { node [s_node] (n100) {0} edge from parent [b_edge] node [above, scale=.7] {0}}
				child { node [s_node] (n101) {1} edge from parent [r_edge] node [above, scale=.7] {1}}
				edge from parent [r_edge] node [above, scale=.7] {0}
			}
			child{ node [s_node] (n11) {1} edge from parent [r_edge] node [above, scale=.7] {1}}
			edge from parent [r_edge] node [above, scale=.7] {1}
		};
	
\end{tikzpicture}
\end{center}

\begin{equation*}
	F = (\overline{x}_{1} \land x_{2} \land x_{3}) \lor (x_{1} \land \overline{x}_{2}\land x_{3}) \lor (x_{1} \land x_{2})
\end{equation*}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} [fragile] {Árvores de decisão}

É importante notar que árvores de decisão são mais fracas do que fórmulas FNC (FND).

\begin{center}
\begin{tikzpicture}[->, scale=.7, level/.style={sibling distance=60mm/#1, level distance = 1.3cm}]

	\node [c_node] (root) {$x_{1}$}
		child { node [c_node] (n0) {$x_{2}$}
			child { node [s_node] (n00) {0} edge from parent [r_edge] node [above, scale=.7] {0}}
			child { node [c_node] (n01) {$x_{3}$}
				child { node [s_node] (n010) {0} edge from parent [r_edge] node [above, scale=.7] {0}}
				child {node [s_node] (n011) {1} edge from parent [b_edge] node [above, scale=.7] {1}}
				edge from parent [r_edge] node [above, scale=.7] {1}
			}
			edge from parent [r_edge] node [above, scale=.7] {0}
                     }
		child{ node [c_node] (n1) {$x_{2}$}
			child{ node [c_node] (n10) {$x_{3}$}
				child { node [s_node] (n100) {0} edge from parent [r_edge] node [above, scale=.7] {0}}
				child { node [s_node] (n101) {1} edge from parent [b_edge] node [above, scale=.7] {1}}
				edge from parent [r_edge] node [above, scale=.7] {0}
			}
			child{ node [s_node] (n11) {1} edge from parent [b_edge] node [above, scale=.7] {1}}
			edge from parent [r_edge] node [above, scale=.7] {1}
		};
	
\end{tikzpicture}
\end{center}

\begin{equation*}
	F = (x_{1} \lor x_{2}) \land (x_{1} \lor \overline{x}_{2} \lor x_{3}) \land (\overline{x}_{1} \lor x_{2} \lor x_{3})
\end{equation*}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} [fragile] {Circuitos}

Um circuito Booleano é composto de portas lógicas computando uma das funções em $\{\land, \lor, \lnot)$ e fios ligando estas portas lógicas como mosta a figura abaixo:

\begin{center}
\begin{tikzpicture}[->, scale=.4]

	\node [v_node] (x1) at (0, 9) {$x_{1}$};
	\node [v_node] (nx1) at (2, 9) {$\overline{x}_{1}$};
	\node [v_node] (x2) at (4, 9) {$x_{2}$};
	\node [v_node] (nx2) at (6, 9) {$\overline{x}_{2}$};
	\node [v_node] (x3) at (8, 9) {$x_{3}$};
	\node [v_node] (nx3) at (10, 9) {$\overline{x}_{3}$};
	\node [v_node] (x4) at (12, 9) {$x_{4}$};
	\node [v_node] (nx4) at (14, 9) {$\overline{x}_{4}$};
	
	\node [g_node] (a11) at (1, 7) {$\land$};
	\node [g_node] (a12) at (5, 7) {$\land$};
	\node [g_node] (a13) at (9, 7) {$\land$};
	\node [g_node] (a14) at (13, 7) {$\land$};
	
	\node [g_node] (o21) at (3, 5) {$\lor$};
	\node [g_node] (o22) at (11, 5) {$\lor$};
	
	\node [g_node] (n31) at (6, 4) {$\lnot$};
	\node [g_node] (n32) at (8, 4) {$\lnot$};
	
	\node [g_node] (a41) at (5, 2) {$\land$};
	\node [g_node] (a42) at (9, 2) {$\land$};
	
	\node [g_node] (o51) at (7, 0) {$\lor$};
	
	\foreach \from/\to in {x1/a11, nx2/a11, nx1/a12, x2/a12, x3/a13, nx4/a13, nx3/a14, x4/a14,
	                                   a11/o21, a12/o21, a13/o22, a14/o22,
	                                   o21/n31, o22/n32,
	                                   o21/a41, n32/a41, n31/a42, o22/a42,
	                                   a41/o51, a42/o51}
		\draw (\from) -- (\to);
		
\end{tikzpicture}
\end{center}

Este circuitos tem 4 variáveis de entrada (sem contar a negação de cada variável). Todos circuitos tem uma única porta lógica no nível mais alto, o valor desta porta lógica é a saída do circuito.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Circuitos}

Nós dizemos que um circuito $C$ com $n$ variáveis de entrada computa $f: \binalph^{n} \to \binalph$ se $C(x) = f(x)$, para todos $x \in \binalph^{n}$.

\begin{itemize}

	\item O circuito do slide anterior computa a função $\Parity_{4}$.
	
	\begin{itemize}
	
		\item $\Parity_{4}(x) = 1$ se e somente se $x_{1} + x_{2} + x_{3} + x_{4} \equiv 1 \pmod{2}$.
		
	\end{itemize}

\end{itemize}

O tamanho de um circuito é o número de portas lógicas e a tua profundidade é o tamanho do maior caminho de uma variável de entrada até a porda de saída.

\begin{itemize}

	\item O nosso circuito para $Parity_{4}$ tem tamanho 11 e profundidade 4.
	
	\item Em geral, $\Parity_{n}$ tem um circuito de tamanho $\mathcal{O}(n)$ e profundidade $\mathcal{O}(\log n)$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} [fragile] {Circuitos}

Pela lei de De Morgan nós podemos empurrar as portas $\lnot$ para as variáveis de entrada.

\begin{itemize}
	\item Se o circuito original tinha tamanho $S$ então o circuito resultante tem tamanho $\leq 2S$.
\end{itemize}

\begin{center}
\begin{tikzpicture}[->, scale=.4]

	\node [v_node] (x1) at (0, 11) {$x_{1}$};
	\node [v_node] (nx1) at (2, 11) {$\overline{x}_{1}$};
	\node [v_node] (x2) at (4, 11) {$x_{2}$};
	\node [v_node] (nx2) at (6, 11) {$\overline{x}_{2}$};
	\node [v_node] (x3) at (8, 11) {$x_{3}$};
	\node [v_node] (nx3) at (10, 11) {$\overline{x}_{3}$};
	\node [v_node] (x4) at (12, 11) {$x_{4}$};
	\node [v_node] (nx4) at (14,11) {$\overline{x}_{4}$};
	
	\node [g_node] (a11) at (0, 8) {$\land$};
	\node [g_node] (a12) at (2, 8) {$\land$};
	
	\node [g_node] (o13) at (4, 7) {$\lor$};
	\node [g_node] (o14) at (6, 7) {$\lor$};
	
	\node [g_node] (o15) at (8, 7) {$\lor$};
	\node [g_node] (o16) at (10, 7) {$\lor$};
	
	\node [g_node] (a17) at (12, 8) {$\land$};
	\node [g_node] (a18) at (14, 8) {$\land$};
	
	\node [g_node] (o21) at (1, 5) {$\lor$};
	\node [g_node] (a22) at (5, 4) {$\land$};
	
	\node [g_node] (a23) at (9, 4) {$\land$};
	\node [g_node] (o24) at (13, 5) {$\lor$};
	
	\node [g_node] (a31) at (3, 2) {$\land$};
	\node [g_node] (a32) at (11, 2) {$\land$};
	
	\node [g_node] (o41) at (7, 0) {$\lor$};
	
	\foreach \from/\to in {x1/a11, nx2/a11, nx1/a12, x2/a12, x1/o13, nx2/o13, nx1/o14, x2/o14, x3/o15, nx4/o15, nx3/o16, x4/o16, x3/a17, nx4/a17, nx3/a18, x4/a18,
				      a11/o21, a12/o21, o13/a22, o14/a22, o15/a23, o16/a23, a17/o24, a18/o24,
				      o21/a31, a23/a31, a22/a32, o24/a32,
				      a31/o41, a32/o41}
		\draw (\from) -- (\to);


\end{tikzpicture}
\end{center}

O circuito acima também computa $\Parity_{4}$ e tem tamanho 15.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Complexidade de circuitos}

Dada uma função $f: \binalph^{n} \to \binalph$ nós queremos saber qual é o menor circuito que computa $f$.

\begin{itemize}

	\item Seja $\mathscr{C}$ o conjunto de circuitos que computam $f$.
	
	\item $\Size(f) = \min_{C \in \mathscr{C}}\{ \lvert C \rvert \}$.

\end{itemize}

Se $f: \binalph^{*} \to \binalph$ então temos que definir uma sequência de circuitos $\{C_{n}\}_{n \geq 1}$ onde cada $C_{n}$ computa $f$ restrita à strings de tamanho $n$.

\begin{itemize}

	\item $\Size(f) = \mathcal{O}(g)$ se existem constantes $c$ e $n_{0}$ tal que $\lvert C_{n} \rvert \leq cg(n)$, para todos $n \geq n_{0}$.
	
	\item Como já comentamos, $\Size(\Parity) = \mathcal{O}(n)$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Complexidade de circuitos: $\Ppoly$}

Algumas classes de complexidade de circuitos:

\begin{itemize}

	\item $\Ppoly:$ circuitos de tamanho polinomial.
	
	\begin{itemize}
	
		\item Contém toda a classe $\P$.
		
		\item Contém todas as linguagens unárias.
		
		\begin{itemize}
		
			\item Logo contém alguns problemas indecidíveis.
	
		\end{itemize}
		
		\item A tua versão $(\P$-)uniforme (ou $\loguniform$) coincide com a classe $\P$.
	
	\end{itemize}

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Complexidade de circuitos: $\Ppoly$}

\begin{itemize}

	\item Problema em aberto: $\NP \subseteq \Ppoly$?
	
	\begin{itemize}
	
		\item $\NP \not\subseteq \Ppoly$ implicaria em $\P \neq \NP$.
		
		\item Teorema de Karp-Lipton: $\NP \subseteq \Ppoly \Rightarrow \PH = \Sigma_{2}^{p}$.
	
	\end{itemize}
	
	\item Problema em aberto: Existe, para todo $k \geq 1$, uma linguagem em $\P$ que não admite circuitos de tamanho $n^{k}$?
	
	\begin{itemize}
	
		\item Suponha que $\P \neq \NP$, isto é verdade porque a classe $\NP$ não admite circuitos pequenos ou é porque circuitos para problemas em $\P$ são pequenos demais?
	
	\end{itemize}

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Complexidade de circuitos: $\NC$ e $\AC$}

Algumas classes de complexidade de circuitos:

\begin{itemize}

	\item $\NC^{i}$: circuitos de tamanho polinomial e profundidade $\log^{i} n$.
	
	\item $\NC = \bigcup_{i \geq 0} \NC^{i}$.
	
	\begin{itemize}
	
		\item Exemplo: computar a determinante de uma matriz está em $\NC$.
	
	\end{itemize}
	
	\item $\AC^{i}$: circuitos de tamanho polinomial, profundidade $\log^{i} n$ e fan-in arbitrário.
	
	\item $\AC = \bigcup_{i \geq 0} \AC^{i}$.
	
	\item $\NC^{0} \subseteq \AC^{0} \subseteq \NC^{1} \subseteq \AC^{1} \subseteq \dots \Rightarrow \NC = \AC$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} [fragile] {Complexidade de circuitos: $\NC$ e $\AC$}

Um circuito $\AC^{0}$ é qualquer circuito com fn-in arbitrário e que alterna portas $\lor$ e portas $\land$.
	
\begin{itemize}

	\item Por exemplo, o seguite circuito é um circuito $\AC^{0}$ para $\Parity_{4}$.

\end{itemize}

\begin{center}
\begin{tikzpicture}[->, scale=.6]

	\node [v_node] (x1) at (0, 6) {$x_{1}$};
	\node [v_node] (nx1) at (2, 6) {$\overline{x}_{1}$};
	\node [v_node] (x2) at (4, 6) {$x_{2}$};
	\node [v_node] (nx2) at (6, 6) {$\overline{x}_{2}$};
	\node [v_node] (x3) at (8, 6) {$x_{3}$};
	\node [v_node] (nx3) at (10, 6) {$\overline{x}_{3}$};
	\node [v_node] (x4) at (12, 6) {$x_{4}$};
	\node [v_node] (nx4) at (14, 6) {$\overline{x}_{4}$};
	
	\node [g_node] (a11) at (0, 2) {$\land$};
		\draw (nx1) -- (a11);
		\draw (nx2) -- (a11);
		\draw (nx3) -- (a11);
		\draw (x4) -- (a11);
	\node [g_node] (a12) at (2, 2) {$\land$};
		\draw (nx1) -- (a12);
		\draw (nx2) -- (a12);
		\draw (x3) -- (a12);
		\draw (nx4) -- (a12);
	\node [g_node] (a13) at (4, 2) {$\land$};
		\draw (nx1) -- (a13);
		\draw (x2) -- (a13);
		\draw (nx3) -- (a13);
		\draw (nx4) -- (a13);
	\node [g_node] (a14) at (6, 2) {$\land$};
		\draw (nx1) -- (a14);
		\draw (x2) -- (a14);
		\draw (x3) -- (a14);
		\draw (x4) -- (a14);
	\node [g_node] (a15) at (8, 2) {$\land$};
		\draw (x1) -- (a15);
		\draw (nx2) -- (a15);
		\draw (nx3) -- (a15);
		\draw (nx4) -- (a15);
	\node [g_node] (a16) at (10, 2) {$\land$};
		\draw (x1) -- (a16);
		\draw (nx2) -- (a16);
		\draw (x3) -- (a16);
		\draw (x4) -- (a16);
	\node [g_node] (a17) at (12, 2) {$\land$};
		\draw (x1) -- (a17);
		\draw (x2) -- (a17);
		\draw (nx3) -- (a17);
		\draw (x4) -- (a17);
	\node [g_node] (a18) at (14, 2) {$\land$};
		\draw (x1) -- (a18);
		\draw (x2) -- (a18);
		\draw (x3) -- (a18);
		\draw (nx4) -- (a18);
	
	\node [g_node] (o21) at (7, 0) {$\lor$};
		\draw (a11) -- (o21);
		\draw (a12) -- (o21);
		\draw (a13) -- (o21);
		\draw (a14) -- (o21);
		\draw (a15) -- (o21);
		\draw (a16) -- (o21);
		\draw (a17) -- (o21);
		\draw (a18) -- (o21);

\end{tikzpicture}
\end{center}

\begin{itemize}

	\item Todas fórmulas FNC e FND são circuitos $\AC^{0}$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\Tribes$}

A função $\Tribes_{w, s}: \binalph^{ws} \to \binalph$ é definida da seguinte forma:

\begin{equation*}
	\Tribes_{w, s}(x) = \bigvee_{i = 1}^{s} (x_{1, i} \land x_{2, i} \land \dots \land x_{w, i}).
\end{equation*}

Onde as variáveis são indexadas por $(i, j) \in [w] \times [s]$.

\begin{itemize}

	\item $\Tribes_{w, s}$ é trivialmente computável por um circuito FND de tamanho $s + 1$.
	
	\item Toda árvore de decisão que computa $\Tribes_{w, s}$ tem que ter profundidade $ws$ --- $\Tribes_{w, s}$ é evasiva.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\Tribes_{n}$}

Nós estamos mais interessados na seguinte escolha de parâmetros:

\begin{itemize}

	\item Para cada $w \geq 1$, escolhemos $s$ o maior inteiro tal que
	
	\begin{equation*}
		(1 - 2^{-w})^{s} = \Pr[\Tribes_{w, s}(x) = 0] \geq 1/2.
	\end{equation*}
	
	\item $n = ws$.

\end{itemize}

Desta forma temos que $\Tribes_{n}$ é uma função ``imparcial'', os valores 1 e 0 aparece com basicamente a mesma probabilidade. Também temos que

\begin{itemize}

	\item $s = \Theta(\frac{n}{\log n})$.
	
	\item $w = \log n - \log\log n - o(1)$.

\end{itemize}

Na verdade, $s \approx 2^{w}ln(2)$ e portanto $(1 - 2^{-w})^{s} \rightarrow 1/2$ com $w \rightarrow \infty$.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Teorema de Baker-Gill-Solovay}

O teorema de Baker-Gill-Solovay diz que existem oráculos $A$ e $B$ tais que

\begin{itemize}

	\item $\P^{A} = \NP^{A}$.
	
	\item $\P^{B} \neq \NP^{B}$.

\end{itemize}

Nós podemos provar que existe $B$ tal que $\P^{B} \neq \NP^{B}$ (a parte não-trivial do teorema) usando o fato que a função $\Tribes_{n}$ é evasiva.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Teorema de Baker-Gill-Solovay - Prova}

Seja $M$ uma máquina de Turing de tempo polinomial que tem uma fita de oráculo e $x \in \binalph^{*}$. Nós consideramos o seguinte:

\begin{itemize}

	\item $\mathcal{X}$ um subconjunto finito de $\binalph^{*}$.
	
	\item $A \subseteq \binalph^{*} \setminus \mathcal{X}$ um oráculo.
	
	\item $T_{M^{A}, x}^{\mathcal{X}}$ uma árvore de decisão que recebe a string característica de um oráculo subconjunto de $\mathcal{X}$.
	
	\begin{itemize}
	
		\item A string característica de $B \subseteq \mathcal{X}$ é a string $x_{B}$ que é 1 no $i$-ésimo bit se a $i$-ésima string em $\mathcal{X}$ (sobre alguma enumeração das strings binárias) está em $B$.
	
	\end{itemize}
	
	\item $T_{M^{A}, x}^{\mathcal{X}}(x_{B}) = 1 \iff M^{A \cup B}(x) = 1$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} [fragile] {Teorema de Baker-Gill-Solovay - Prova}

Se $M$ é uma máquina de Turing de tempo polinomial e $x \in \binalph^{*}$.

\begin{center}
\begin{tikzpicture}[->, scale=.7, level/.style={sibling distance=150mm/#1, level distance = .8cm}]
		
	\node [t_node] (root) {algumas computações}
		child { node [t_node] (n1) {consulta à alguma string em $\mathcal{X}$}
			child { node [dots_node] (n2) {$\vdots$}
				child { node [t_node] (n3) {algumas computações}
					child { node [dots_node] (n5) {$\vdots$}
						child { node [t_node] (n6) {consulta à alguma string em $\mathcal{X}$}
							child { node [dots_node] (n7) {$\vdots$} edge from parent node [above, scale=.4] {0}}
							child {node [t_node] (n8) {aceita} edge from parent node [above, scale=.4] {1}}
							edge from parent [draw=none]
						}
						edge from parent [draw=none]
					}
					edge from parent [draw=none]
				}
				edge from parent node [above, scale=.4] {0}
			}
			child { node [dots_node] (n9) {$\vdots$}
				child { node [t_node] (n10) {algumas computações}
					child { node [dots_node] (n11) {$\vdots$}
						child { node [t_node] (n12) {consulta à alguma string em $\mathcal{X}$}
							child {node [dots_node] (n13) {$\vdots$} edge from parent node [above, scale=.4] {0}}
							child {node [dots_node] (n14) {$\vdots$} edge from parent node [above, scale=.4] {1}}
							edge from parent [draw=none]
						}
						edge from parent [draw=none]
					}
					edge from parent [draw=none]
				}
				edge from parent node[above, scale=.4] {1}
			}
		};
		
	\begin{scope} [yshift=-6cm, ->, scale=.7, level/.style={sibling distance=60mm/#1, level distance = 1.5cm}]
	
		\node [] (arrow) {$\Downarrow$}
			child { node [c_node2] (root2) {$x_{4}$}
				child { node [c_node2] (n15) {$x_{6}$}
					child {node [dots_node] (n16) {$\vdots$} edge from parent node [above, scale=.4] {0}}
					child {node [s_node2] (n17) {1} edge from parent node [above, scale=.4] {1}}
					edge from parent node [above, scale=.4] {0}
				}
				child { node [c_node2] (n18) {$x_{11}$}
					child {node [dots_node] (n19) {$\vdots$} edge from parent node [above, scale=.4] {0}}
					child {node [dots_node] (n20) {$\vdots$} edge from parent node [above, scale=.4] {1}}
					edge from parent node [above, scale=.4] {1}
				}
				edge from parent [draw=none]
			};
		
	\end{scope}

\end{tikzpicture}
\end{center}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Teorema de Baker-Gill-Solovay - Prova}

No caso especial em que $\mathcal{X} = \binalph^{n}$, $n = \lvert x \rvert$.

\begin{itemize}

	\item $T_{M^{A}, x}^{\binalph^{n}}$ tem profundidade polilogarítmica (o que é $\ll n$).
		
	\item Pois se $M$ roda em tempo $\leq n^{c}$ então $M$ faz no máximo $n^{c}$ consultas ao oráculo.
		
	\item $n^{c} = \polylog(2^{n})$.
		
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Teorema de Baker-Gill-Solovay - Prova}

Nós consideramos a seguinte linguagem.

\begin{equation*}
	L(B) = \{1^{n} \lvert \Tribes_{n_{w}}(x_{B^{=n}}) = 1\}
\end{equation*}

\begin{itemize}

	\item $n_{w}$ satisfaz $2^{n - 1} < n_{w} \leq 2^{n}$ (tal $n_{w}$ é unico). 

	\item $B^{=n} = B \cap \binalph^{n}$.

	\item Como o tamanho da string $x_{B^{=n}}$ pode ser menor do que $2^{n}$ a entrada da função $\Tribes_{n_{w}}$ é na verdade a string $x_{B^{=n}}$ truncada.

\end{itemize}

Para todos $A \subseteq \binalph^{*}$, $L(A) \in \NP^{A}$.

\begin{itemize}

	\item Dado um índice $i$ que é múltiplo de $s$ (o número de tribos) verifica se as strings $x^{(i + 1)}, \dots, x^{(i + w - 1)}$ estão em $A$ com $\Theta(\frac{n}{\log n})$ consultas.
	
	\begin{itemize}
	
		\item $x^{(i)}$ é a $i$-ésima string de tamanho $n$ na ordem lexicográfica.

	\end{itemize}

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Teorema de Baker-Gill-Solovay - Prova}

$M_{1}, M_{2}, \dots$ uma enumeração de máquinas de Turing de tempo polinomial e $p_{1}, p_{2}, \dots$ seus tempos de execução. Escolha $n_{1}$ de forma que $p_{1}(n_{1}) < 2^{n_{1}}$ e $B(0) = \emptyset$.

\begin{itemize}

	\item Primeiro estágio:
	
	\begin{itemize}
	
		\item Defina $B^{\prime}$ de forma que $T_{M^{B(0)}, 1^{n_{1}}}^{\binalph^{n_{1}}}(x_{B^{\prime}}) \neq \Tribes_{n_{w}}(x_{B^{\prime}})$ (as funções $\Tribes$ são evasivas).
	
		\item Faça $B(1) = B(0) \cup B^{\prime}$.
	
	\end{itemize}

	\item $i$-ésimo estágio:
	
	\begin{itemize}
	
		\item Escolha $n_{i}$ tal que $p_{i}(n_{i}) < 2^{n_{i}}$ e $n_{i} > n_{i - 1}$.
		
		\item $B^{\prime}$ tal que $T_{M^{B(i - 1)}, 1^{n_{i}}}^{\binalph^{n_{i}}}(x_{B^{\prime}}) \neq \Tribes_{n_{w}}(x_{B^{\prime}})$
		
		\item Faça $B(i) = B(i - 1) \cup B^{\prime}$.
	
	\end{itemize}

	\item Por fim nós fazemos $B = \bigcup_{i \geq 1} B(i)$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Teorema de Baker-Gill-Solovay - Prova}

Então podemos argumentar que $\P^{B} \neq \NP^{B}$.

\begin{itemize}

	\item Nós definimos cada $B(i)$ de forma que a máquina $M_{i}$ falha em decidir $L(B)$ corretamente na entrada $1^{n_{i}}$ quando $M_{i}$ tem acesso a $B(i)$.
	
	\item Como $B(i)$ é consistente com $B$, $M_{i}$ deve falhar em decidir $L(B)$ corretamente na entrada $1^{n_{i}}$ com acesso a $B$.

\end{itemize}

\qed

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\P \neq \NP$ para oráculos aleatórios} 

Além de $\Tribes_{n}$ ser evasiva, ela nem mesmo pode ser aproximada por árvores de decisão com profundidade polilogarítmica.

\begin{itemize}

	\item Nós dizemos que a árvore de decisão $T$ aproxima uma função $f$ se $T(x) = f(x)$ para quase todas as entradas.

\end{itemize}

\begin{teo} \label{tribes_inaproximability}

Seja $A$ qualquer algoritmo de consulta com complexidade de consulta $o(\frac{n}{logn})$, então:

\begin{equation*}
    \Pr_{x \sim \binalphn}[A(x) = \Tribes_{n}(x)] < 0,51
\end{equation*}

\end{teo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\P \neq \NP$ para oráculos aleatórios}

Bastar provar que qualquer árvore de consulta que faz consultas à somente uma fração constante das tribos não consegue aproximar $\Tribes_{n}$.

\begin{itemize}

	\item $g(x) = 1 \iff \text{ pelo menos uma das primeiros  } \frac{1}{100} \text{ das tribos é unanimamente 1}$.
	
	\item Temos que $\Pr[\Tribes_{n}(x) \neq g(x)] = \E[(\Tribes_{n}(x) - g(x))^{2}]$.

	\item Como $\Tribes_{n}(x) \geq g(x)$:
	
	\begin{itemize}
	
		\item $\Pr[\Tribes_{n}(x) \neq g(x)] = \E[\Tribes_{n}(x) - g(x)]$.
	
	\end{itemize}

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\P \neq \NP$ para oráculos aleatórios}

Então temos que

\begin{IEEEeqnarray*} {rCl}
	\Pr[\Tribes_{n} \neq g(x)] & = & \E[\Tribes_{n}(x) - g(x)] \\
	                                           & = & \E[\Tribes_{n}(x)] - \E[g(x)] \\
	                                           & = & \Pr[\Tribes_{n}(x) = 1] - \Pr[g(x) = 1] \\
	                                           & = & 1 - (1 - 2^{-w})^{s} - 1 + (1 - 2^{-w})^{\frac{1}{100}}s \\
	                                           & = & (1 - 2^{-w})^{\frac{1}{100}s} - (1 - 2^{-w})^{s}.
\end{IEEEeqnarray*}

Com $w$ tendendo ao infinito isso é maior do que

\begin{equation*}
	2^{-1/100} - 1/2 - 0,001 > 0,492.
\end{equation*}

\begin{itemize}

	\item Portanto,
	
	\begin{equation*}
		\Pr[\Tribes_{n}(x) = g(x)] < 1 - 0,492 = 0,508 < 0,51.
	\end{equation*}

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\P \neq \NP$ para oráculos aleatórios - Lei 0-1 de Kolmogorov}

\begin{itemize}

	\item Para uma sequência $X_{1}, X_{2}, \dots$ de variáveis aleatórias mutualmente independentes:
	
	\begin{itemize}
	
		\item $G_{n} = \sigma \Big(\bigcup_{i = n}^{\infty} X_{i} \Big)$ é a menor $\sigma$-álgebra para qual cada $X_{i}, i \geq n$, é mensurável.
		
		\item $\mathcal{T} = \bigcap_{n = 1}^{\infty} G_{n}$ é a $\sigma$-álgebra caudal de $X_{1}, X_{2}, \dots$.
	
	\end{itemize}

\end{itemize}

\begin{teo}

Seja $X_{1}, X_{2}, \dots$ uma sequência de variáveis aleatórias independentes e $\mathcal{T}$ a $\sigma$-álgebra caudal destes eventos. Então todo evento $E \in \mathcal{T}$ satisfaz $\Pr[E] \in \{0, 1\}$.

\end{teo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Revisando a prova do teorema de Baker-Gill-Solovay}

Para provar o teorema de Baker-Gill-Solovay nós utilizamos os seguintes passos:

\begin{itemize}

	\item Máquina de Turing com acesso a um oráculo e uma string:
	
	\begin{itemize}
	
		\item Árvore de decisão de profundidade polilogarítmica.
	
	\end{itemize}
	
	\item Para cada oráculo $B \subseteq \binalph^{*}$ nós definimos a linguagem unária $L(B)$ que está em $\NP^{B}$.
	
	\begin{itemize}
	
		\item Cada $L(B)$ está ``estruturada'' da mesma forma usando as funções $\Tribes_{n}$.
	
	\end{itemize}

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Revisando a prova do teorema de Baker-Gill-Solovay}

Para provar o teorema de Baker-Gill-Solovay nós utilizamos os seguintes passos (continuando):

\begin{itemize}

	\item Nós definimos uma sequência $n_{1}, n_{2}, \dots$, com $1 \leq n_{1} < n_{2} < \dots$.

	\item Árvores de decisão de profundidade polilogarítmica não são capazes de computar as funções $\Tribes_{n}$:
	
	\begin{itemize}
	
		\item Um oráculo $B(i)$ em que a $i$-ésima máquina de Turing de tempo polinomial falha em decidir $L(B(i))$ para a string $1^{n_{i}}$ relativo a $B(i)$.
	
	\end{itemize}
	
	\item E como último passo nós fazemos $B = \bigcup_{i \geq 1} B(i)$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Revisando a prova do teorema de Baker-Gill-Solovay}

Agora vamos considerar $\mathcal{C}_{1}$ e $\mathcal{C}_{2}$ classe de complexidades quaisquer e queremos provar que existe um oráculo $B \subseteq \binalph^{*}$ tal que $\mathcal{C}_{1}^{B} \neq \mathcal{C}_{2}^{B}$. 

\begin{itemize}

	\item Um predicado $P$ para uma linguagem em $\mathcal{C}_{1}$ e uma string $x$:
	
	\begin{itemize}
	
		\item Representados por alguma classe $\mathcal{D}$ de ``dispositivos computacionais''.
		
		\item Ou seja, $P(B, x) = 1 \iff D_{x}(B) = 1$, onde $D_{x} \in \mathcal{D}$.
	
	\end{itemize}
	
	\item Para cada oráculo $B \subseteq \binalph^{*}$ nós definimos a linguagem unária
	
	\begin{equation*}
		L(B) = \{1^{n} \lvert f(x_{B}) = 1\},
	\end{equation*}
	
	\item para alguma função $f$ que não pode ser computada em $\mathcal{D}$ e tal que $L(B) \in \mathcal{C}_{2}^{B}$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Revisando a prova do teorema de Baker-Gill-Solovay}

Agora vamos considerar $\mathcal{C}_{1}$ e $\mathcal{C}_{2}$ classe de complexidades quaisquer e queremos provar que existe um oráculo $B \subseteq \binalph^{*}$ tal que $\mathcal{C}_{1}^{B} \neq \mathcal{C}_{2}^{B}$ (continuando). 

\begin{itemize}

	\item Daí podemos repetir o mesmo argumento que usamos para a prova do Teorema de Baker-Gill-Solovay.
	
\end{itemize}

Ou seja, podemos generalizar a prova do teorema de Baker-Gill-Solovay para provar outras separações por oráculo.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\PH$ vs $\PSPACE$ relativizado}

Lembrando a classe $\PH$:

\begin{itemize}

	\item Para todo $k \geq 1$, uma linguagem $L$ está em $\Sigma_{k}^{p}$ se e somente se
	
	\begin{equation*}
		x \in L \iff \exists x_{1} \forall \dots Q_{k} x_{k} M(x, x_{1}, \dots, x_{k} = 1,
	\end{equation*}
	
	onde $M$ é uma máquina de Turing que roda em tempo $p(n)$ e $Q_{k}$ é $\exists$ se $k$ é ímpar e $\forall$ se $k$ é par.
	
	\begin{itemize}
	
		\item Cada $x_{i}$ tem tamanho no máximo $p(\lvert x \rvert)$.
	
	\end{itemize}
	
	\item $\PH = \bigcup_{i \geq 1} \Sigma_{k}^{p}$.
	
	\item Vamos denotar a classe $\Sigma_{k}^{p}$ com acesso à oráculo $B$ por $\Sigma_{k}^{p, B}$.
	
	\item $\PH^{B} = \bigcup_{i \geq 1} \Sigma_{k}^{p, B}$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\PH$ vs $\PSPACE$ relativizado}

Nós já sabemos que $\PH \subseteq \PSPACE$. É verdade que existe $B \subseteq \binalph^{*}$ tal que $\PH^{B} \nsupseteq \PSPACE^{B}$?

\begin{itemize}

	\item Um predicado $P_{k, i}$ em $\Sigma_{k}^{p}$ é
	
	\begin{equation*}
		P_{k, i}(x) \iff \exists x_{1} \forall \dots Q_{k} x_{k} M_{i}(x, x_{1}, \dots, x_{k}) = 1,
	\end{equation*}
	
	onde $M_{i}$ é a $i$-ésima máquina de Turing de tempo polinomial e $Q_{k}$ é $\exists$ ou $\forall$ dependendo de $k$ ser ímpar ou par, respectivamente.
	
	\item Podemos então enumerar todos os predicados $P_{i}$ em $\PH$.
	
	\item Para $x \in \binalph^{*}$ e $B \subseteq \binalph^{*}$:
	
	\begin{equation*}
		P_{i, x}(B) = 1 \iff P_{i}^{B}(x) = 1,
	\end{equation*}
	
	onde $P_{i}^{B}$ é o predicado $P_{i}$ com acesso ao oráculo $B$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\PH$ vs $\PSPACE$ relativizado}

O primeiro passo para provar que existe um oráculo $B$ tal que $\PH^{B} \neq \PSPACE^{B}$ é mostrar que $P_{i, x}$ pode ser representado por um circuito $\AC^{0}$.

\begin{itemize}

	\item Um predicado $\PH$ $P_{i}$ é da forma
	
	\begin{equation*}
		P_{i}(X) \iff \exists x_{1} \forall x_{2} \dots Q_{k} x_{k} M_{i}(x, x_{1}, \dots, x_{k}) = 1.
	\end{equation*}
	
	\begin{itemize}
	
		\item Cada quantificador $\exists \Rightarrow$ uma camada de portas $\lor$.
		
		\item Cada quantificador $\forall \Rightarrow$ uma camada de portas $\land$.
	
	\end{itemize}
	
	\item Representamos $P_{i, x} \equiv P_{k, i, x}$, para algum $k \geq 1$, por um circuito $\AC^{0}$ de profundidade $k + 1$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} [fragile] {$\PH$ vs $\PSPACE$ relativizado}

\begin{center}
\begin{tikzpicture}[scale=.7, level/.style={sibling distance=180mm/#1, level distance = .8cm}]
	
	\node [t_node, scale=1] (root) {$P_{i}(x) \iff \exists x_{1} \forall \dots \exists_{k} x_{k} M_{i}(x, x_{1}, \dots, x_{k}) = 1$};
	
	\begin{scope}[yshift=-1cm, ->, scale=.7, level/.style={sibling distance=60mm/#1, level distance = 1.5cm}]
	
		\node [] (arrow) {$\Downarrow$};
	
	\end{scope}
	
	\begin{scope}[yshift=-2.5cm, scale=.7, level/.style={sibling distance=60mm/#1, level distance = 1.5cm}]
	
		\node [dt_node] at (-6, 0) {};
			\draw (-6.6, 1) -- (-6.6, 0.55);
			\draw (-6.2, 1) -- (-6.2, 0.55);
			\node [draw=none, scale=.5] (dots1) at (-5.8, .7) {$\dots$};
			\draw (-5.4, 1) -- (-5.4, 0.55);
			
		\node [dt_node] at (-2, 0) {};
			\draw (-2.6, 1) -- (-2.6, 0.55);
			\draw (-2.2, 1) -- (-2.2, 0.55);
			\node [draw=none, scale=.5] (dots2) at (-1.8, .7) {$\dots$};
			\draw (-1.4, 1) -- (-1.4, .55);
		
		\node [draw=none, scale=1.5] (dots3) at (2, -.3) {$\dots$};
	
		\node [dt_node] at (6, 0) {};
			\draw (5.4, 1) -- (5.4, 0.55);
			\draw (5.8, 1) -- (5.8, 0.55);
			\node [draw=none, scale=.5] (dots3) at (6.2, .7) {$\dots$};
			\draw (6.6, 1) -- (6.6, .55);
		
		\node [o_node] at (0, -4) {Circuito $\AC^{0}$ com profundidade k e portas $\lor$ no nível mais baixo};
			\draw [->] (-6, -1) -- (-5, -3.5);
			\draw [->] (-2, -1) -- (-1, -3.5);
			\draw [->] (2, -1) -- (2, -3.5);
			\draw [->] (6, -1) -- (5, -3.5);
	
	\end{scope}

\end{tikzpicture}
\end{center}

Cada árvore de decisão representa a computação de $M_{i}$ com a entrada $x$ e todas as possíveis escolhas de $x_{1}, x_{2}, \dots, x_{k}$.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} [fragile] {$\PH$ vs $\PSPACE$ relativizado}

\begin{center}
\begin{tikzpicture}[scale=.7, level/.style={sibling distance=180mm/#1, level distance = .8cm}]
	
	\node [t_node, scale=1] (root) {$P_{i}(x) \iff \exists x_{1} \forall \dots \forall_{k} x_{k} M_{i}(x, x_{1}, \dots, x_{k}) = 1$};
	
	\begin{scope}[yshift=-1cm, ->, scale=.7, level/.style={sibling distance=60mm/#1, level distance = 1.5cm}]
	
		\node [] (arrow) {$\Downarrow$};
	
	\end{scope}
	
	\begin{scope}[yshift=-2.5cm, scale=.7, level/.style={sibling distance=60mm/#1, level distance = 1.5cm}]
	
		\node [dt_node] at (-6, 0) {};
			\draw (-6.6, 1) -- (-6.6, 0.55);
			\draw (-6.2, 1) -- (-6.2, 0.55);
			\node [draw=none, scale=.5] (dots1) at (-5.8, .7) {$\dots$};
			\draw (-5.4, 1) -- (-5.4, 0.55);
			
		\node [dt_node] at (-2, 0) {};
			\draw (-2.6, 1) -- (-2.6, 0.55);
			\draw (-2.2, 1) -- (-2.2, 0.55);
			\node [draw=none, scale=.5] (dots2) at (-1.8, .7) {$\dots$};
			\draw (-1.4, 1) -- (-1.4, .55);
		
		\node [draw=none, scale=1.5] (dots3) at (2, -.3) {$\dots$};
	
		\node [dt_node] at (6, 0) {};
			\draw (5.4, 1) -- (5.4, 0.55);
			\draw (5.8, 1) -- (5.8, 0.55);
			\node [draw=none, scale=.5] (dots3) at (6.2, .7) {$\dots$};
			\draw (6.6, 1) -- (6.6, .55);
		
		\node [o_node] at (0, -4) {Circuito $\AC^{0}$ com profundidade k e portas $\land$ no nível mais baixo};
			\draw [->] (-6, -1) -- (-5, -3.5);
			\draw [->] (-2, -1) -- (-1, -3.5);
			\draw [->] (2, -1) -- (2, -3.5);
			\draw [->] (6, -1) -- (5, -3.5);
	
	\end{scope}

\end{tikzpicture}
\end{center}

Cada árvore de decisão representa a computação de $M_{i}$ com a entrada $x$ e todas as possíveis escolhas de $x_{1}, x_{2}, \dots, x_{k}$.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\PH$ vs $\PSPACE$ relativizado}

Para um predicado $P_{i, x}$ nós temos um circuito $C_{P_{i}, x}$ com $N = 2^{\poly(\lvert x \rvert)}$ entradas que satisfaz:

\begin{itemize}

	\item Tamanho $\Theta(2^{k}N)$ e profundidade $k + 1$.
	
	\item Fan-in $\mathcal{O}(\log N)$ nas portas lógicas no nível mais baixo e fan-in $\mathcal{O}(N)$ nas demais portas.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\PH$ vs $\PSPACE$ relativizado}

Consideramos a seguinte linguagem para cada $B \subseteq \binalph^{*}$:

\begin{equation*}
	L(B) = \{1^{n} \lvert \Parity(B^{=n}) = 1\}
\end{equation*}

Nós temos que $\L(B) \in \PSPACE^{B}$. Nós temos o seguinte teorema:

\begin{teo}

Seja $d > 0$ um inteiro. Para $n$ suficientemente grande temos que qualquer circuito de profundidade $d$ com fan-in $\polylog(n)$ no teu primeiro nível e tamanho $< 2^{\mathcal{O}\big(n^{\frac{1}{d - 1}}\big)}$ não pode computar a função paridade de $n$ variáveis corretamente em todas as entradas. 

\end{teo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {$\PH$ vs $\PSPACE$ relativizado}

\begin{teo}

Seja $d > 0$ um inteiro. Para $n$ suficientemente grande temos que qualquer circuito de profundidade $d$ com fan-in $\polylog(n)$ no teu primeiro nível e tamanho $< 2^{\mathcal{O}\big(n^{\frac{1}{d - 1}}\big)}$ não pode computar a função paridade de $n$ variáveis corretamente em todas as entradas. 

\end{teo}

\begin{itemize}

	\item Como haviamos discutidos, isto prova que existe um oráculo $B \subseteq \binalph^{*}$ tal que $\PH^{B} \neq \PSPACE^{B}$.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Separando a hierarquia polinomial}

Para separar a hierarquia polinomia relativo a algum oráculo nós temos que mostar que existe um oráculo $B \subseteq \binalph^{*}$ tal que para todo $k \geq 1$

\begin{equation*}
	\Sigma_{k - 1}^{p, B} \neq \Sigma_{k}^{p, B}
\end{equation*}

\begin{itemize}

	\item Nós temos que mostrar que um único oráculo separa várias classes.
	
	\item O nosso framework funciona para este caso?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Separando a hierarquia polinomial}

Para cada $B \subseteq \binalph^{*}$ e $k > 1$ temos a seguinte linguagem:

\begin{equation*}
	L(B, k) = \{1^{n} \lvert f^{k + 1, N}(B^{=n}) = 1\}
\end{equation*}

Onde $N = \big( \sqrt{2/(k + 1)}2^{n}\big)^{\frac{1}{k}}$ e $f^{k, n}$ são as funções de Sipser:

\begin{defi} \label{Sipser_f}

A função de Sipser $f^{k, n}$ é definida da seguinte forma:

\begin{equation} \label{Sipser_f_def_1}
	\bigvee_{i_{k}  = 1}^{\sqrt{\frac{n}{\log n}}}\bigwedge_{i_{k - 1} = 1}^{n} \dots \bigwedge_{i_{2} = 1}^{n} \bigvee_{i_{1} = 1}^{\sqrt{\frac{1}{2}dn\log n}} x_{i_{1}, i_{2}, \dots, i_{k}}, \text{ se } k \text{ é par.}
\end{equation}

e

\begin{equation} \label{Sipser_f_def_2}
	\bigvee_{i_{k}  = 1}^{\sqrt{\frac{n}{\log n}}}\bigwedge_{i_{k - 1} = 1}^{n} \dots \bigvee_{i_{2} = 1}^{n} \bigwedge_{i_{1} = 1}^{\sqrt{\frac{1}{2}dn\log n}} x_{i_{1}, i_{2}, \dots, i_{k}}, \text{ se } k \text{ é ímpar.}
\end{equation}

\end{defi}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Separando a hierarquia polinomial}

E nós podemos ver que as funções $f^{k, d}$ têm profundidade $k$ e tamanho

\begin{equation*}
	1 + \sum_{i = 0}^{k - 2}n^{i}\sqrt{\frac{n}{\log n}} = 1 + \Big( \frac{n^{k - 1} - 1}{n - 1}\Big)\sqrt{\frac{n}{\log n}}
\end{equation*}

O número de variáveis de entrada de $f^{k, n}$ é

\begin{equation*}
	m = n^{k - 2}\sqrt{\frac{n}{\log n}}\sqrt{\frac{1}{2}kn\log n} = n^{k - 1}\sqrt{k/2}.
\end{equation*}

E daí vemos que o circuito para $f^{k, n}$ tem tamanho linear.

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Separando a hierarquia polinomial}

Nós também temos um limitante inferior para as funçõs $f^{k, n}$:

\begin{teo} \label{Sipser_f_lb}

Seja $k > 2$ e $n$ suficientemente grande, qualquer circuito de tamanho $< 2^{\Theta\big(\sqrt{\frac{n}{k\log n}}\big)}$ e profundidade $k - 1$ não computa a função $f^{k, n}$ corretamente em todas as entradas.

\end{teo}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame} {Separando a hierarquia polinomial}

\begin{itemize}

	\item Seja $P_{1}, P_{2}, \dots$ uma enumeração de todos os predicados $\PH$ tal que cada $i$ é em particular um predicado $\Sigma_{k_{i}}^{p}$, para algum $k_{i} \geq 1$.

	\item Seja $n_{1}, n_{2}, \dots$ uma sequência de inteiros tal que:
	
	\begin{enumerate}
	
		\item $C_{P_{i}, 1^{n_{i}}}$ tem tamanho polinomial e fan-in no nível mais baixo polilogarítmico.
		
		\item $1 < n_{1} < n_{2} < \dots$.
	
	\end{enumerate}

	\item Para cada $i$ nós podemos fazer $P_{i}$ falhar em computar $L(B, k_{i} + 1)$ na entrada $1^{n_{i}}$ graças ao limitante inferior para as funções de Sipser.
	
	\item Isto é suficiente para construir um oráculo $B$ que faz a hierarquia polinomial ser infinita.

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}