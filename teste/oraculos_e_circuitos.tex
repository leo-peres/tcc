\chapter{Computação relativizada e complexidade de circuitos}

Neste capítulo nós vemos como circuitos e complexidade ``relativizada'' se relacionam. Antes de tudo definiremos rapidamente o que queremos dizer por complexidade de espaço.

\begin{defi}(Complexidade de espaço)

Uma linguagem $L$ é dita estar em SPACE($T(n)$) para uma função $T: \mathbb{N} \to \mathbb{N}$ se existe uma máquina de Turing $M$ que decide $L$ usando menos do que $T(n)$ células da fita.

\end{defi}

\begin{defi} (Classe PSPACE)

Uma linguagem $L$ é dita estar em PSPACE se e somente se $L \in \text{SPACE}(p(n))$, para algum polinômio $p$.

\end{defi}

Uma linguagem $L$ é PSPACE-completa se $L \in $ PSPACE e todas linguagens em PSPACE são redutíveis à $L$ em tempo polinomial. Um exemplo de linguagem PSPACE-completa é QUANT-SAT, satisfazibilidade de fórmulas quantificadas. Aqui nós percebemos uma relação entre a classe PSPACE e a hierarquia polinomial.

\begin{teo}

    PH $\subseteq$ PSPACE.

\end{teo}

Isso é verdade pois todas as linguagens em PH podem ser expressas através de uma fórmula quantificada mais a redução de Cook-Levin.

\section{Uma prova alternativa do teorema \ref{teo: bgs}}

Nós já vimos que existem oráculos $A$ e $B$ satisfazendo $\P^{A} = \NP^{A}$ e $\P^{B} \neq \NP^{B}$. Neste capítulo nós vemos uma outra prova do segundo resultado que mostra a idéia geral em como conectamos limites inferiores a resultados em complexidade relativizada. Basicamente, nós usamos a incapacidade de certos dispositivos computacionais (por exemplo, circuitos de baixa profundidade) de computar certas funções mais o fato que certas classes de complexidade poderem ser expressas por estes mesmos dispositivos computacionais para, ironicamente, diagonalizar e provar separação por oráculo. Note que essa é a mesma idéia que usamos anteriormente para provar o teorema \ref{teo: bgs}, porém se tentassemos generalizar aquele argumento para provar que $\PH^{A} \neq \PSPACE^{A}$ nós esbarrariamos em alguns problemas como por exemplo ter que simular cada máquina de Turing um número exponencial de vezes o que destroi a nossa hipótese que uma máquina de Turing de tempo polinomial só faz uma quantidade polinomial de consultas ao oráculo, e também podemos ver que trabalhar com modelos que apresentam uma estrutura combinatórica como circuitos Booleanas é muito menos problemático.

Vamos considerar de novo a função Tribes$_{n}$ que nós vimos no capítulo anterior. Uma das propriedades de Tribes$_{n}$ é que ela é \emph{evasiva}, o que significa que ter conhecimento apenas parcial dos bits da entrada não é suficiente para avaliar a função. Para formalizar isso, suponha que nós temos uma função $f: \{0, 1\}^{n} \to \{0, 1\}$ e queremos computar $f(x)$ para alguma entrada $x$. Nós podemos fazer isso somente consultando cada bit de $x$ sem nos preocuparmos com a complexidade das computações intermediárias. Desta formas podemos definir diversas medidas de complexidade de $f$. A medida que nos interessa no momento é a complexidade de consulta determinística:

\begin{defi}

A complexidade de consulta determinística de um algoritmo $A$ é o maior número de consulta aos bits da entrada sobre todas as entradas $x \in \{0, 1\}^{n}$ que $A$ faz.

Seja $f: \{0, 1\}^{n} \to \{0, 1\}$. A complexidade de consulta determinística de $f$, que denotamos por $D(f)$, é o mínimo da complexidade de consulta determinística de todos os algoritmos que computam $f$.

\end{defi}

A partir de agora quando dissermos complexidade de consulta fica implícito que estamos falando da complexidade de consulta determinística.

Nós podemos representar as consultas feita pelo algoritmo através de uma árvore de decisão, onde em cada consulta o algoritmo ramifica para a esquerda ou para direita dependendo do valor do bit consultado. Desta forma $D(f)$ é a profundidade mínima entre todas as árvores de decisão que computam $f$.

Para ver que Tribes$_{n}$ é evasiva bastar considerar o cenário em que nenhuma consulta revela o valor de uma das tribos (isto é, a consulta sempre retorna 1) até que o último bit da tribo seja consultado e acaba sendo 0, assim mesmo que todas exceto uma tribo tenha todos seus bits revelados o valor desta última tribo vai ser incerto até que a última consulta seja feita. Isso pode ser traduzido como $D(\text{Tribes}_{n}) = n$. Também poderiamos ter usado o seguinte fato:

\begin{fato}
Para todas funções $f: \{0, 1\}^{n} \to \{0, 1\}$, $deg(f) \leq D(f)$.
\end{fato}

E como vimos em \ref{prop: tribes_fourier_coef}, deg(Tribes$_{n}$) = n.

Agora, seja $M$ uma máquina de Turing que pode fazer consultas a algum oráculo, e seja $x \in \binalph^{*}$. O que $M$ faz antes de tua primeira consulta é independente de qual oráculo ela tem acesso, e o que $M$ faz entre a primeira e segunda consulta só depende da resposta à primeira consulta, e por aí vai. Isto sugere que a computação de $M$ sobre a entrada $x$ pode ser representada por um algoritmo de consulta que ramifica sobre as respostas às tuas consultas ao oráculo.

Seja $\mathcal{X}$ um subconjunto finito de $\binalph^{*}$ e $A \subseteq \binalph^{*}$ um oráculo que inicialmente está definido apenas nas strings que não estão em $\mathcal{X}$. Sejam $M$ e $x$ os mesmos do parágrafo anterior, então o algoritmo de consulta $T_{M^{A}, x}^{\mathcal{X}}$ ramifica sobre consultas ao oráculo por strings em $\mathcal{X}$. Podemos ver a entrada de $T_{M^{A}, x}^{\mathcal{X}}$ como um vetor característica $v$ onde $v_{j} = 1$ significa que a $j$-ésima string na ordem lexicográfica em $\mathcal{X}$ está em $A$. Desta forma, temos que $T_{M^{A}, x}^{\mathcal{X}}(v) = 1 \iff M^{A \cup v}(x) = 1$, permitindo um pequeno abuso de notação. Em particular, se $M$ roda em tempo polinomial e $\mathcal{X} = \binalph^{\lvert x \rvert}$ então $T_{M^{A}, x}^{\mathcal{X}}$ tem complexidade de consulta polilogarítmica se $\lvert x \rvert$ for suficientemente grande.

Então, para cada oráculo $A \subseteq \{0, 1\}^{*}$, considere a seguinte linguagem.

\begin{equation*}
L_{A} = \{1^{n} \lvert \text{Tribes}_{N}(A) = 1\}
\end{equation*}

Com $N$ satisfazendo $2^{n - 1} \leq N \leq 2^{n}$ e Tribes$_{N}(A)$ significando a função Tribes$_{N}$ com o vetor característica de $A^{=n}$ em seu argumento, mas como $N$ pode ser menor do que $2^{n}$ nós na verdade truncamos a string para que ela tenha tamanho igual a $N$. $L_{A} \in \NP^{A}$ para todos $A \subseteq \{0, 1\}^{*}$ pois precisamos apenas verificar que para algum $i$ múltiplo de $w$, $x_{i}, x_{i + 1}, \dots, x_{i + w - 1} \in A$, em que $x_{i}$ é a $i$-ésima string de tamanho $n$ na ordem lexicográfica. Com isso dito, podemos provar o teorema \ref{teo: bgs} novamente:

\begin{prop} \label{prop: p_vs_np_r}

Existe um oráculo $A \subseteq \{0, 1\}^{*}$ tal que $L_{A} \notin P^{A}$.

\end{prop}

\begin{proof}

Seja $\{M_{i}\}_{i \geq 1}$ uma enumeração de todas as máquinas de Turing de tempo polinomial, e $\{p_{i}\}_{i \geq 1}$ o tempo de execução das respectivas máquinas de Turing.

Assim como fizemos na primeira prova do teorema \ref{teo: bgs}, vamos construir o oráculo $A$ em estágios. Inicialmente $A = \emptyset$ e $n_{1}$ é o menor inteiro tal que $2^{n_{1}} > p_{1}(n_{1})$ para todos $n \geq n_{1}$. Consideramos então o $i$-ésimo estágio e fazemos as seguintes definições:

\begin{itemize}

    \item $A(i - 1)$ é o conjuto (finito) de todas as strings que já foram declaradas em $A$ após o estágio $i - 1$.

    \item $n_{i}$ é um inteiro que satisfaz

    \begin{enumerate}

        \item é maior do que o tamanho de todas as strings já declaradas em $A(i - 1)$;

        \item $2^{n_{i}} > p_{i}(n_{i})$;

        \item $2^{n_{i} - 1} \leq N \leq 2^{n_{i}}$, para algum $N$ que pode ser definido como em \ref{prop: tribes_n} (lembrando que este $N$ é único).

    \end{enumerate}

    \item $D(i) = \bigcup_{k = n_{i}}^{p_{i}(n_{i})}\{0, 1\}^{k}$.


\end{itemize}

Como o algoritmo de consulta de $M_{i}$ sobre a entrada $1^{n_{i}}$ tem complexidade de consulta polilogaritmica e Tribes$_{N}$ é evasiva, segue que existe um oráculo $A^{\prime} \subseteq \{0, 1\}^{*}$ tal que $T_{M_{i}^{A(i - 1)}, 1^{n_{i}}}^{\binalph^{n_{i}}}(A^{\prime}) \neq \text{Tribes}_{N}(A^{\prime})$. Seja $B = A^{\prime} \cap D_{i}$ e $A(i) = A(i - 1) \cup B$, nós podemos argumentar que $M_{i}$ não pode ser uma máquina de Turing que decide $L_{A(i)}$ pois:

\begin{itemize}

    \item Se $M_{i}^{A^{\prime}}(1^{n_{i}}) = 0 \Rightarrow \text{Tribes}_{N}(A^{\prime}) = 1$ e portanto $1^{n_{i}} \in L_{A(i)}$.

    \item Se $M_{i}^{A^{\prime}}(1^{n_{i}}) = 1 \Rightarrow \text{Tribes}_{N}(A^{\prime}) = 0$ e portanto $1^{n_{i}} \notin L_{A(i)}$.

\end{itemize}

    Por fim, nós fazemos $A = \bigcup_{i \geq 1}A(i)$ e pelo nosso argumento todas as máquinas de Turing de tempo polinomial com acesso a $A$ deixam de computar $L_{A}$ corretamente em pelo menos uma entrada e portanto $L_{A} \notin P^{A}$.

\end{proof}

Na prova que acabamos de ver nós usamos dois fatos a respeito da função Tribes$_{N}$: 1) ela é evasiva (na verdade só precisamos do fato que Tribes$_{n}$ não pode ser computada por um algoritmo que faz $\Omega(n^{c})$ consultas, para qualquer $c > 0$) e 2) ela admite 1-certificados (em algum lugar eu explico o que é isso) pequenos. Portanto poderiamos substituir Tribes$_{n}$ por qualquer função que satisfaça 1 e 2, como por exemplo a função $Or_{n}$, a disjunção de $N$ variáveis. Porém, a função $Or_{n}$ não é balanceada, uma propriedade que nós vamos precisar na seção seguinte.

\section{P $\neq$ NP para oráculos aleatórios}

Um dos objetivos de estudar complexidade relativizada é enteder a relação entres classes de complexidades quando não conseguimos dizer nada de muito útil no mundo não-relativizado. Porém, como vemos pelo teorema \ref{teo: bgs}, provar que P $\neq$ NP para algum oráculo não é nenhuma evidência que P $\neq$ NP no mundo não-relativizado, até porque a construção do oráculo $A$ em ambas provas que vimos é só uma especialização do método da diagonalização que por sua vez é basicamente só uma forma de ``trapacear o sistema'' construido uma asserção que codifica a tua própria falsidade. Então, com o objetivo de conseguir algum tipo de evidência que P $\neq$ NP poderiamos nos perguntar se é o caso que P e NP são diferentes no mundo relativizado típico. E de fato, o próximo teorema é o assunto desta subseção:

\begin{teo} \label{teo: P_NP_random_oracles}

$Pr_{A}[\P^{A} \neq \NP^{A}] = 1$.

\end{teo}

Antes de ver a prova do teorema \ref{teo: P_NP_random_oracles} nós vamos discutir o que queremos dizer por $\P^{A} \neq \NP^{A}$ com probabilidade 1.

\subsubsection{A lei zero-um de Kolmogorov}

A lei zero-um de Kolmogorov nos diz que certos eventos sempre acontecem com probabilidade 0 ou com probabilidade 1. O que isso quer dizer, e que eventos são esses? 


\subsubsection{Prova do teorema \ref{teo: P_NP_random_oracles}}

A idéia principal do teorema \ref{teo: P_NP_random_oracles} é que a função $Tribes_{n}$ não pode nem mesmo ser aproximada por algoritmos de consulta com complexidade de consulta polilogarítmica.

\begin{prop} \label{prop: tribes_inaproximability}

Seja $A$ qualquer algoritmo de consulta com complexidade de consulta $o(\frac{n}{logn})$, então:

\begin{equation*}
    \Pr_{x \sim \binalphn}[A(x) = \Tribes_{n}(x)] < 0,65 
\end{equation*}

\end{prop}

\begin{proof}

É suficiente provar que qualquer algoritmo de consulta que faz consultas a no máximo $\frac{1}{10}s$ das tribos não pode aproximar $\Tribes_{n}$.

Seja $A$ tal algoritmo de consultas. Nós usamos o fato que para qualquer entrada $x$ em que $A$ não ``descobre'' uma tribo que é unanimamente $1$, o melhor que $A$ pode fazer é adivinhar o valor de $Tribes_{n}(x)$. Chamamos tal entrada $x$ de ``má''. Então:

\begin{equation*}
    \Pr_{x \in \binalphn}[x \text{ é má}] \geq 9/10
\end{equation*}

Se $x$ é má então $Tribes_{n}(x) = 1$ se e somente se pelo menos uma das $\frac{9}{10}s$ tribos restantes é unanimamente 1. Isso acontece com probabilidade $1 - (1 - 2^{-w})^{\frac{9}{10}s}$, mas temos que para $w$ suficientemente grande e $\varepsilon > 0$:

\begin{equation*}
    1/2 \leq (1 - 2^{-w})^{\frac{9}{10}s} \leq (1/2 + \varepsilon)^{\frac{9}{10}}
\end{equation*}

 Ou seja, condicionando em nenhuma das primeiros $\frac{1}{10}s$ tribos serem unanimamente 1, o melhor que $A$ pode fazer é adivinhar que $\Tribes_{n}(x) = 0$ e ainda assim $A$ não poderá fazer melhor do que acertar numa fração maior do que, por exemplo, 0,55 das vezes. Então:

\begin{equation*}
	\Pr_{x \sim \binalphn}[A(x) = \Tribes_{n}(x)] < 1/10 + 0,55 = 0,65.
\end{equation*}

\end{proof}

\color{red} Alternativamente podemos provar o teorema anterior da seguinte forma:

\begin{proof}

De novo nós provamos que qualquer algoritmo $A$ que só faz consultas às primeiras $\frac{1}{10}s$ tribos não pode aproximar a função $\Tribes_{n}$. Podemos notar que neste caso o melhor que podemos fazer é fazer $A$ computar a função $\Tribes_{\frac{1}{10}s, w}$, ou seja, se $g$ é a função computada por $A$, então

\begin{equation*}
	g(x) = 1 \iff \text{pelo menos uma das primeiras } \frac{1}{10}s \text{ tribos é unanimamente 1}.
\end{equation*}

Daí temos que

\begin{equation*}
	\Pr_{x \sim \binalphn}[\Tribes_{n}(x) \neq g(x)] = \E_{x \sim \binalphn}[(\Tribes_{n}(x) - g(x))^{2}].
\end{equation*}

Mas como $\Tribes_{n}(x) \geq g(x)$, para todos $x \in \binalphn$, temos que

\begin{IEEEeqnarray*}{rCl}
	\Pr_{x \sim \binalphn}[\Tribes_{n}(x) \neq g(x)] & = & \E_{x \sim \binalphn}[\Tribes_{n}(x) - g(x)] \\
	                                                                             & = & \E_{x \sim \binalphn}[\Tribes_{n}(x)] - \E_{x \sim \binalphn}[g(x)] \\
	                                                                             & = & \widehat{\Tribes_{n}}(\emptyset) - \widehat{g}(\emptyset) \\
	                                                                             & = & 1 - (1 - 2^{-w})^{s} - 1  + (1 - 2^{-w})^{\frac{1}{10}s} \\
	                                                                             & = & (1 - 2^{-w})^{\frac{1}{10}s} - (1 - 2^{-w})^{s}
\end{IEEEeqnarray*}

Com $w$ tendendo ao infinito isso é igual a $2^{-\frac{1}{10}} - 1/2 \approx 0,433$, e portanto

\begin{equation*}
	\Pr_{s \sim \binalphn}[\Tribes_{n}(x) = A(x)] \leq 1 - 0,433 = 0,567.
\end{equation*}

\end{proof}

Na verdade, como nós só precisamos provar que algoritmos que fazem uma quantidade polilogarítmica de consultas não podem aproximar $\Tribes_{n}$ nós podemos mudar a fração de tribos consultadas para algo como $\frac{\log^{d} n}{n}$ e daí temos que a probabilidade que $A$ coincide com $\Tribes_{n}$ seria algo como $1/2 + o(1)$.

\color{black}

Então podemos provar o teorema \ref{teo: P_NP_random_oracles}.

\begin{proof} (Prova do teorema \ref{teo: P_NP_random_oracles})

Pela proposição \ref{prop: tribes_inaproximability} nós temos que para uma fração significativa das entradas, $T_{M^{A(i - 1)}, 1^{n_{i}}}^{\binalph^{n_{i}}}(A^{\prime}) \neq Tribes_{N}(A^{\prime})$ e portanto o conjunto $\{A \subseteq \binalph^{*} \lvert \P^{A} \neq \NP^{A}\}$ tem medida (de Lebesgue?) positiva.

\end{proof}

\section{PH vs PSPACE}

Agora nós generalizamos a idéia que usamos para separar $\P$ e $\NP$ nas seções anteriores para podermos separar $\PSPACE$ e a hierarquia polinomial. Da mesma forma que usamos árvores de decisão para representar $\P$ nós iremos usar circuitos $\AC^{0}$ para representar $\PH$.

Fixe $k \geq 1$. Seja $L \subseteq \binalph^{*}$ uma linguagem em $\Sigma_{k}^{p}$, o que significa que existe uma máquina de Turing $M$ de tempo polinomial tal que para todo $x \in \binalph^{*}$, $x \in L \iff \exists y_{1} \forall y_{2} \dots Q_{k} y_{k} M(x, y_{1}, y_{2}, \dots, y_{k}) = 1$. Fixando ${y}_{1}, y_{2}, \dots, y_{k}$, podemos representar a computação de $M$ sobre $x, {y}_{1}, y_{2}, \dots, y_{k}$ por uma árvore de decisão da forma que vimos anteriormente. Então o circuito $\AC^{0}$ $C_{M, x}^{\mathcal{X}}$ que usamos para representar $L$ tem profundidade $k + 1$ onde cada quantificador $\exists$ é representado por uma porta $\lor$ e $\forall$ é representado por uma porta $\land$, a profundidade é $k + 1$ porque no nível mais baixo nós temos árvores de decisão que podem ser representadas por fórmulas FNC ou FND. Também vemos que o fan-in das portas no primeiro nível é $\polylog(n)$ e o fan-in nas demais portas é $2^{p(n)}$, o tamanho do circuito é $N^{\polylog(N)}$, onde $N = 2^{n}$, o tamanho da entrada de $C_{M, x}^{\mathcal{X}}$.

\begin{teo} \label{teo: pspace_vs_ph_r}

Existe $A \subseteq \binalph^{*}$ tal que $\PSPACE^{A} \neq \PH^{A} = \bigcup_{k \geq 1} \Sigma_{k}^{p, A}$.

\end{teo}

Nós provamos \ref{prop: p_vs_np_r} a partir de um limite inferior para a função $\Tribes_{N}$. Para provar o teorema \ref{teo: pspace_vs_ph_r} nós iremos usar um limite inferior para a função paridade de $n$ variáveis.

\begin{defi} (Paridade)

Para $n \geq 1$ a função paridade de $n$ variáveis é 1 se e se somente se $\sum_{i = 1}^{n} x_{1} \pmod{2} = 1$.

\end{defi}

Consideremos para cada oráculo $A \subseteq \binalph^{*}$ a seguinte linguagem:

\begin{equation*}
    L(A) = \{1^{n} \lvert A(x) = 1 \text{ para um número ímpar de } x \in \binalphn\}.
\end{equation*}

E temos que $L(A) \in \PSPACE^{A}$ já que só precisamos de espaço para escrever cada string de $n$ bits na fita de oráculo mais uma célula para guardar a paridade de $\lvert \{x \in \binalphn \lvert A(x) = 1)\} \rvert$.

O teorema a seguir nos dá o limite inferior necessário para podermos provar que $L(A) \not\in \PH^{A}$ para algum oráculo $A \subseteq \binalph^{*}$. 

\begin{teo} \label{teo: parity_lb}

Seja $d > 0$ um inteiro. Para $n$ suficientemente grande temos que qualquer circuito de profundidade $d$ com fan-in $\polylog(n)$ no teu primeiro nível e tamanho $< 2^{\mathcal{O}\big(n^{\frac{1}{d - 1}}\big)}$ não pode computar a função paridade de $n$ variáveis corretamente em todas as entradas. 

\end{teo}

Nós iremos provar o teorema \ref{teo: parity_lb} no próximo capítulo. Na verdade, iremos ganhar de grátis o seguinte teorema.

\begin{teo} \label{teo: parity_lb_app}

Seja $d > 0$ um inteiro. Então qualquer circuito com profundidade $d$, fan-in do primeiro nível $\polylog(n)$ que computa a função paridade de $n$ variáveis corretamente numa fração maior do que $1/2 + \Omega(n^{-d})$ das entradas deve ter tamanho maior do que $2^{\Theta\big(n^{\frac{1}{d - 1}}\big)}$.

\end{teo}

E portanto temos o seguinte.

\begin{teo} \label{teo: pspace_vs_ph_random}

$\Pr_{A}[\PSPACE^{A} \neq \PH^{A}] = 1$.

\end{teo}

\begin{proof} (Prova do Teorema \ref{teo: pspace_vs_ph_r})

Nós usamos o argumento usual.

Seja $\{M_{i}\}_{i \geq 1}$ uma enumeração de todas as máquinas de Turing de tempo polinomial e $\{p_{i}\}_{i \geq 1}$ o tempo de execução dessas máquinas de Turing. Fixe algum $k \geq 1$ e provaremos que existe $A \subseteq \binalph^{*}$ tal que $\PSPACE^{A} \neq \Sigma_{k}^{p, A}$.

Inicialmente faça $A = \emptyset$ e seja $n_{1}$ tal que $p_{1}(n_{1}) < 2^{n_{1}}$, seja $D(1) = \bigcup_{l = n_{1}}^{p_{1}(n_{1})} \binalph^{l}$. Seja $A^{\prime}$ tal que $C_{M, 1^{n_{1}}}^{\binalph^{n_{1}}}(A^{\prime}) \neq \Parity_{p_{1}(n_{1})}(A^{\prime})$ (tal $A^{\prime}$ deve existir por $C_{M, 1^{n_{1}}}^{\binalph^{n_{1}}}$ ter tamanho $\subexp(n_{1})$ e pelo Teorema \ref{teo: parity_lb}). Daí fazemos $A(1) = A \cup (D(1) \cap A^{\prime})$ e finalizamos o primeiro estágio.

Estágio $i$:

Escolha $n_{i}$ tal que $n_{i} > p_{i - 1}(n_{i - 1})$ e $p_{i}(n_{i}) < 2^{n_{i}}$, seja $A(i - 1)$ o conjunto de todas as strings declarada em $A$ antes do $i$-ésimo estágio e $D(i) = \bigcup_{l = n_{i}}^{p_{i}(n_{i})}$. De novo, escolha $A^{\prime}$ tal que $C_{M_{i}, 1^{n_{i}}}^{\binalph^{n_{i}}}(A^{\prime}) \neq \Parity_{p_{i}(n_{i})}(A^{\prime})$. Então fazemos $A(i) = A(i - 1) \cup (D(i) \cap A^{\prime})$.

Argumentaremos que $A = \bigcup_{i = 1}^{\infty}A(i)$ satisfaz $L(A) \not\in \Sigma_{k}^{p, A}$.

Suponha que uma das $M_{i}s$ decida $L(A)$ com $k$ quantificadores alternantes e com acesso a $A$. Então:

\begin{itemize}

    \item $1^{n_{i}} \in L(A) \Rightarrow C_{M_{i}, 1^{n_{i}}}(A) = 1 \Rightarrow C_{M_{i}, 1^{n_{i}}}(A(i)) = 1 \Rightarrow \Parity_{p_{i}(n_{i})} = 0$.

    \item $1^{n_{i}} \not\in L(A) \Rightarrow C_{M_{i}, 1^{n_{i}}}(A) = 0 \Rightarrow C_{M_{i}, 1^{n_{i}}}(A(i)) = 0 \Rightarrow \Parity_{p_{i}(n_{i})} = 1$.

\end{itemize}

Ambos os casos são contradições pois $1^{n} \in L(A) \iff \Parity_{2^{n}}(A) = 1$.
\end{proof}

\section{Separando a hierarquia polinomial}

Como vimos na seção anterior, podemos representar $\Sigma_{k}^{p}$ por circuitos $\AC^{0}$ com profundidade $k + 1$. Portanto, se queremos provar que existe $A \subseteq \binalph^{*}$ tal que $\Sigma_{k}^{p, A} \not\subseteq \Sigma_{k - 1}^{p. A}$ nós temos que demonstrar a existência de uma ''hierarquia de profundidade``, ou seja, que existe, para cada $k > 1$ uma função $f_{k}$ tal que existe um circuito de tamanho polinomial e profundidade $k + 1$ que computa $f_{k}$ mas que qualquer circuito com profundidade $k$ que computa $f_{k}$ tem tamanho exponencial. Note que pelo teorema \ref{teo: parity_lb} a função paridade não pode ser computada por circuitos $\AC^{0}$ de tamanho polinomial e profundidade $k$ para \emph{todas} as constantes $k \geq 1$ e portanto temos que provar limites inferior para funções diferentes da função paridade. Para isso, definiremos as funções de Sipser:

\begin{defi} (As funções de Sipser) \label{Sipser_f}

Para $d \geq 2$ a função de Sipser $f^{d, n}$ é uma fórmula monotônica e \emph{read-once} onde o nível mais baixo tem fan-in $\sqrt{\frac{1}{2}dn\log n}$, as portas lógicas nos níveis 2 até d - 1 têm fan-in $n$ e a porta lógica no nível mais alto tem fan-in $\sqrt{\frac{n}{\log n}}$. Ou seja, podemos escrever $f^{d, n}$ como

\begin{equation} \label{Sipser_f_def_1}
	\bigwedge_{i_{d}  = 1}^{\sqrt{\frac{n}{\log n}}}\bigvee_{i_{d - 1} = 1}^{n} \dots \bigvee_{i_{2} = 1}^{n} \bigwedge_{i_{1} = 1}^{\sqrt{\frac{1}{2}dn\log n}} x_{i_{1}, i_{2}, \dots, i_{d}}, \text{ se } d \text{ é par.}
\end{equation}

e

\begin{equation} \label{Sipser_f_def_2}
	\bigwedge_{i_{d}  = 1}^{\sqrt{\frac{n}{\log n}}}\bigvee_{i_{d - 1} = 1}^{n} \dots \bigwedge_{i_{2} = 1}^{n} \bigvee_{i_{1} = 1}^{\sqrt{\frac{1}{2}dn\log n}} x_{i_{1}, i_{2}, \dots, i_{d}}, \text{ se } d \text{ é ímpar.}
\end{equation}

\end{defi}

Segue direto da definição que o número $m$ de variáveis de entrada da função $f^{d, n}$ é

\begin{equation*}
	m = n^{d - 2}\sqrt{\frac{n}{\log n}}\sqrt{\frac{1}{2}dn\log n} = n^{d - 1}\sqrt{d/2}.
\end{equation*}

Também segue que pela definição de $f^{d, n}$ exposta em \ref{Sipser_f_def_1} e \ref{Sipser_f_def_2} que ela pode ser computada por um circuito de profunidade $d$ e tamanho

\begin{equation*}
	S = 1 + \sum_{i = 0}^{d - 2} n^{i}\sqrt{\frac{n}{\log n}} = 1 + \Big(\frac{n^{d - 1} - 1}{n - 1}\Big)\sqrt{\frac{n}{\log n}},
\end{equation*}

e como $m = \poly(n)$ temos que $S = \poly(m)$. Agora o resultado que nós precisamos para separar cada nível da hierarquia polinomial relativa à um oráculo segue do seguinte resultado, também provado por Håstad em tua tese de doutorado.

\begin{teo} \label{Sipser_f_lb}

Seja $d > 2$ e $n$ suficientemente grande, qualquer circuito de tamanho $< 2^{\Theta\big(\sqrt{\frac{n}{d\log n}}\big)}$ não computa a função $f^{d, n}$ corretamente em todas as entradas.

\end{teo}

De novo, deixaremos a prova do teorema \ref{Sipser_f_lb} para o próximo capítulo, por enquanto só estamos preocupados na seguinte aplicação deste teorema.

\begin{teo} \label{ph_no_collapse_r}
Existe um oráculo $A \subseteq \binalph^{*}$ tal que para todo $k \geq 2$, $\Sigma_{k}^{p, A} \neq \Sigma_{k - 1}^{p, A}$.
\end{teo}

Ou seja, para este oráculo $A$, $PH^{A} \neq \Sigma_{k}^{p, A}$, para todos $k \geq 1$. Logo, em particular, $P^{A} \neq PH^{A} \Rightarrow P^{A} \neq NP^{A}$, então podemos ver a prova do teorema \ref{ph_no_collapse_r} como a terceira prova do teorema de Baker-Gill-Solovay em \ref{teo: bgs} e \ref{prop: p_vs_np_r} que iremos ver, mas desta vez também estaremos provando algo bem mais forte usando basicamente a mesma estratégia.

Desta vez, seja $L(A) = \{1^{n} \lvert f^{k + 1, n}(A) = 1\}$, para algum $k \geq 2$ fixo.

\begin{proof} (Prova do Teorema \ref{ph_no_collapse_r})

Fixe algum $k \geq 2$, iremos provar que $\Sigma_{k}^{p, A} \neq \Sigma_{k - 1}^{p, A}$.

Seja $\{M_{i}\}_{i \geq 1}$ uma enumeração de todas as máquinas de Turing de tempo polinomial e $\{p_{i}\}_{i \geq 1}$ o tempo de execução das respectivas máquinas de Turing. Inicialmente faça $A = A(0) = \emptyset$, seja $n_{1}$ tal que $p_{1}(n_{1}) < 2^{n_{1}}$ e $D(1) = \bigcup_{l = n_{1}}^{p_{1}(n_{1})} \binalph^{l}$. Pelo limite inferior no teorema \ref{Sipser_f_lb} temos que deve existir uma string de oráculo $A^{\prime}$ tal que $C_{M_{1}, 1^{n_{1}}}^{\binalph^{l}}(A^{\prime}) \neq f^{k + 1, n_{1}}(A^{\prime})$. Daí fazemos $A(1) = A(0) \cup (D(1) \cap A^{\prime})$.

Estágio $i$:

Escolha $n_{i}$ tal que $n_{i} > p_{i - 1}(n_{i - 1})$ e $p_{i}(n_{i}) < 2^{n_{i}}$. Seja $D(i) = \bigcup_{l = n_{i}}^{p_{i}(n_{i})}\binalph^{l}$. Daí escolhemos um $A^{\prime}$ tal que $C_{M_{i}, 1^{n_{i}}}^{\binalph^{n_{i}}}(A^{\prime}) \neq f^{k + 1, n_{i}}(A^{\prime})$ e então fazemos $A(i) = A(i - 1) \cup (D(i) \cap A^{\prime})$.

Argumentamos que $A = \bigcup_{i \geq 1}A(i)$ é tal que nenhuma linguagem em $\Sigma_{k - 1}^{p, A}$ seja igual à $L(A)$. Seja L uma linguagem arbitrária em $\Sigma_{k - 1}^{p, A}$ tal que $L$ é expressa como $x \in L \iff \exists x_{1} \in \binalph^{p_{i}(\lvert x \rvert)}\forall \dots Q x_{d - 1 } \in \binalph^{p_{i}(\lvert x \rvert)} M_{i}(x, x_{1}, \dots, x_{d - 1}) = 1$, onde $Q$ é $\forall$ se $k - 1$ for ímpar e $\exists$ se $k - 1$ for par. Por construção temos que

\begin{enumerate}

	\item Se $\exists x_{1} \in \binalph^{p_{i}(n_{i})} \forall \dots Q x_{k - 1} \in \binalph^{p_{i}(n_{i})} M_{i}(1^{n_{i}}, x_{1}, \dots, x_{k - 1}) = 1$ for verdadeiro $\Rightarrow f^{k + 1, n_{i}}(A) = 0$ e portanto $1^{n_{i}} \not\in L(A)$;
	
	\item Se  $\exists x_{1} \in \binalph^{p_{i}(n_{i})} \forall \dots Q x_{k - 1} \in \binalph^{p_{i}(n_{i})} M_{i}(1^{n_{i}}, x_{1}, \dots, x_{k - 1}) = 1$ for falso $\Rightarrow f^{k + 1, n_{i}}(A) = 1$ e portanto $1^{n_{i}} \in L(A)$.

\end{enumerate}

Por (1) temos que $1^{n_{i}} \in L \Rightarrow 1^{n_{i}} \not\in L(A)$ e por (2) temos que $1^{n_{i}} \not\in L \Rightarrow 1^{n_{i}} \in L(A)$ e portanto $L \neq L(A)$. Como $L$ é uma linguagem arbitrária concluimos que nenhuma linguagem em $\Sigma_{k - 1}^{p, A}$ é igual à $L(A)$, ou seja, $L(A) \not\in \Sigma_{k - 1}^{p, A}$.

\color{red}

Se a prova acima estiver basicamente correta então nós provamos que para todo $k \geq 2$ existe um oráculo $A$ tal que $\Sigma_{k}^{p, A} \neq \Sigma_{k - 1}^{p, A}$. Porém, o teorema diz que existe um oráculo $A$ tal que para todos $k \geq 2$, $\Sigma_{k}^{p, A} \neq \Sigma_{k - 1}^{p, A}$. Isto é um problema pois se continuarmos enumerando máquinas de Turing eu não vejo como diagonalizar para todos $k's$, a solução talvez seja enumerar `'predicados PH`` ao invés de máquinas de Turing de tempo polinomial.

\color{black}

\subsubsection{Separando a hierarquia polinomial com oráculos aleatórios}

Recentemente, Rossman, Servedio e Tan (referência) provaram que a hierarquia polinomial não colapsa relativa a um oráculo aleatório. Por ser um trabalho bem técnico e longo nós não tivemos tempo para estudá-los, porém antes de terem provado o resultado absoluto já haviam alguns resultados parciais, como o que nós iremos ver a seguir.

\begin{teo} \label{sigma3_vs_sigma2_r}
	$\Pr_{A \sim \binalph^{*}}[\Sigma_{3}^{p, A} \neq \Sigma_{2}^{p, A}] = 1$.
\end{teo}

E o teorema \ref{sigma3_vs_sigma2_r} segue do seguinte limite inferior para uma fórmula DNF que aproxima uma versão da função $\Tribes$.

\begin{teo} (O'Donnell, Wimmer)

a

\end{teo}

\end{proof}